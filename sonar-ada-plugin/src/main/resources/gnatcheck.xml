<?xml version='1.0' encoding='UTF-8'?>
<rules>
  <rule>
    <key>unconstrained_array_returns</key>
    <name>functions returning unconstrained arrays</name>
    <description>      Flag each function returning an unconstrained array. Function
declarations, function bodies (and body stubs) having no separate
specifications, and generic function instantiations are flagged.
Function calls and function renamings are not flagged.

   Generic function declarations, and function declarations in generic
packages, are not flagged.  Instead, this rule flags the results of
generic instantiations (that is, expanded specification and expanded
body corresponding to an instantiation).

   This rule has the following (optional) parameters for the `+R'
option:

_Except_String_
     Do not flag functions that return the predefined `String' type or
     a type derived from it, directly or indirectly.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>metrics_cyclomatic_complexity</key>
    <name>(metrics) high cyclomatic complexity</name>
    <description>      The `Metrics_Cyclomatic_Complexity' rule takes a positive integer as
upper bound.  A program unit that is an executable body exceeding this
limit will be flagged.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>deeply_nested_inlining</key>
    <name>deeply nested inlining (global check)</name>
    <description>      Flag a subprogram (or generic subprogram) if pragma Inline has been
applied to it, and it calls another subprogram to which pragma Inline
applies, resulting in potential nested inlining, with a nesting depth
exceeding the value specified by the `N' rule parameter.

   This rule requires the global analysis of all the compilation units
that are `gnatcheck' arguments; such analysis may affect the tool's
performance.

   This rule has the following (mandatory) parameter for the `+R'
option:

_N_
     Positive integer specifying the maximum level of nested calls to
     subprograms to which pragma Inline has been applied.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>unassigned_out_parameters</key>
    <name>OUT parameters do not get values in procedure bodies</name>
    <description>      Flag procedures' `out' parameters that are not assigned.

   An `out' parameter is flagged if the sequence of statements of the
procedure body (before the procedure body's exception part, if any)
contains no assignment to the parameter.

   An `out' parameter is flagged in an exception handler in the
exception part of the procedure body, if the exception handler contains
neither an assignment to the parameter nor a raise statement.

   Bodies of generic procedures are also considered.

   The following are treated as assignments to an `out' parameter:
   * an assignment statement, with the parameter or some component as
     the target

   * passing the parameter (or one of its components) as an `out' or
     `in out' parameter.

   This rule has no parameters.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>identifier_casing:exclude</key>
    <name>dictionary of casing exceptions</name>
    <description>      Flag each defining identifier that does not have a casing corresponding
to the kind of entity being declared. All defining names are checked.
For the defining names from the following kinds of declarations a
special casing scheme can be defined:

   * type and subtype declarations;

   * enumeration literal specifications (not including character
     literals) and function renaming declarations if the renaming
     entity is an enumeration literal;

   * constant and number declarations (including object renaming
     declarations if the renamed object is a constant);

   * exception declarations and exception renaming declarations.

   The rule may have the following parameters for `+R':

`Type=_casing_scheme_'
     Specifies casing for names from type and subtype declarations.

`Enum=_casing_scheme_'
     Specifies the casing of defining enumeration literals and for the
     defining names in a function renaming declarations if the renamed
     entity is an enumeration literal.

`Constant=_casing_scheme_'
     Specifies the casing for defining names from constants and named
     number declarations, including the object renaming declaration if
     the renamed object is a constant

`Exception=_casing_scheme_'
     Specifies the casing for names from exception declarations and
     exception renaming declarations.

`Others=_casing_scheme_'
     Specifies the casing for all defining names for which no special
     casing scheme is specified. If this parameter is not set, the
     casing for the entities that do not correspond to the specified
     parameters is not checked.

`Exclude=_dictionary_file_'
     Specifies casing exceptions.

Where:

        casing_scheme ::= upper|lower|mixed

_upper_ means that the defining identifier should be upper-case.
_lower_ means that the defining identifier should be lower-case _mixed_
means that the first defining identifier letter and the first letter
after each underscore should be upper-case, and all the other letters
should be lower-case

   If a defining identifier is from a declaration for which a specific
casing scheme can be set, but the corresponding parameter is not
specified for the rule, then the casing scheme defined by `Others'
parameter is used to check this identifier. If `Others' parameter also
is not set, the identifier is not checked.

   _dictionary_file_ is the name of the text file that contains casing
exceptions. The way how this rule is using the casing exception
dictionary file is consistent with using the casing exception
dictionary in the GNAT pretty-printer `gnatpp', see `GNAT Pro User's
Guide'.

   There are two kinds of exceptions:

_identifier_
     If a dictionary file contains an identifier, then each occurrence
     of that (defining) identifier in the checked source should use the
     casing specified included in _dictionary_file_

_wildcard_
     A wildcard has the following syntax

            WILDCARD ::= *SIMPLE_IDENTIFIER* |
                               *SIMPLE_IDENTIFIER |
                               SIMPLE_IDENTIFIER*
            SIMPLE_IDENTIFIER ::= LETTER{LETTER_OR_DIGIT}

     `simple_identifier' specifies the casing of subwords (the term
     "subword" is used below to denote the part of a name which is
     delimited by "_" or by the beginning or end of the word and which
     does not contain any "_" inside).  A wildcard of the form
     `simple_identifier*' defines the casing of the first subword of a
     defining name to check, the wildcard of the form
     `*simple_identifier' specifies the casing of the last subword, and
     the wildcard of the form `*simple_identifier*' specifies the
     casing of any subword.

     If for a defining identifier some of its subwords can be mapped
     onto wildcards, but some other cannot, the casing of the
     identifier subwords that are not mapped onto wildcards from casing
     exception dictionary is checked against the casing scheme defined
     for the corresponding entity.

   If some identifier is included in the exception dictionary both as a
whole identifier and can be mapped onto some wildcard from the
dictionary, then it is the identifier and not the wildcard that is used
to check the identifier casing.

   If more than one dictionary file is specified, or a dictionary file
contains more than one exception variant for the same identifier, the
new casing exception overrides the previous one.

   Casing check against dictionary file(s) has a higher priority than
checks against the casing scheme specified for a given
entity/declaration kind.

   `+R' option should contain at least one parameter.

   There is no parameter for `-R' option, it just turns the rule off.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>raising_predefined_exceptions</key>
    <name>explicit raise of predefined exceptions</name>
    <description>      Flag each `raise' statement that raises a predefined exception (i.e.,
one of the exceptions `Constraint_Error', `Numeric_Error',
`Program_Error', `Storage_Error', or `Tasking_Error').

   This rule has no parameters.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>overloaded_operators</key>
    <name>operator overloading</name>
    <description>      Flag each function declaration that overloads an operator symbol.  A
function body is checked only if the body does not have a separate
spec. Formal functions are also checked. For a renaming declaration,
only renaming-as-declaration is checked

   This rule has no parameters.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>parameters_out_of_order</key>
    <name>formal parameters ordering</name>
    <description>      Flag each subprogram and entry declaration whose formal parameters are
not ordered according to the following scheme:

   * `in' and `access' parameters first, then `in out' parameters, and
     then `out' parameters;

   * for `in' mode, parameters with default initialization expressions
     occur last

Only the first violation of the described order is flagged.

   The following constructs are checked:

   * subprogram declarations (including null procedures);

   * generic subprogram declarations;

   * formal subprogram declarations;

   * entry declarations;

   * subprogram bodies and subprogram body stubs that do not have
     separate specifications

Subprogram renamings are not checked.

   This rule has no parameters.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>function_style_procedures</key>
    <name>procedures looking like functions</name>
    <description>      Flag each procedure that can be rewritten as a function. A procedure
can be converted into a function if it has exactly one parameter of
mode `out' and no parameters of mode `in out'. Procedure declarations,
formal procedure declarations, and generic procedure declarations are
always checked. Procedure bodies and body stubs are flagged only if
they do not have corresponding separate declarations. Procedure
renamings and procedure instantiations are not flagged.

   If a procedure can be rewritten as a function, but its `out'
parameter is of a limited type, it is not flagged.

   Protected procedures are not flagged. Null procedures also are not
flagged.

   This rule has no parameters.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>identifier_prefixes:type</key>
    <name>prefix for type names (empty string disables check)</name>
    <description>      Flag each defining identifier that does not have a prefix corresponding
to the kind of declaration it is defined by. The defining names in the
following kinds of declarations are checked:

   * type and subtype declarations (task, protected and access types
     are treated separately);

   * enumeration literal specifications (not including character
     literals) and function renaming declarations if the renaming
     entity is an enumeration literal;

   * exception declarations and exception renaming declarations;

   * constant and number declarations (including object renaming
     declarations if the renamed object is a constant).

Defining names declared by single task declarations or single protected
declarations are not checked by this rule.

   The defining name from the full type declaration corresponding to a
private type declaration or a private extension declaration is never
flagged. A defining name from an incomplete type declaration is never
flagged.

   The defining name from a subprogram renaming-as-body declaration is
never flagged.

   For a deferred constant, the defining name in the corresponding full
constant declaration is never flagged.

   The defining name from a body that is a completion of a program unit
declaration or a proper body of a subunit is never flagged.

   The defining name from a body stub that is a completion of a program
unit declaration is never flagged.

   Note that the rule checks only defining names. Usage name occurrence
are not checked and are never flagged.

   The rule may have the following parameters:

   * For the `+R' option:
    `Type=_string_'
          Specifies the prefix for a type or subtype name.

    `Concurrent=_string_'
          Specifies the prefix for a task and protected type/subtype
          name. If this parameter is set, it overrides for task and
          protected types the prefix set by the Type parameter.

    `Access=_string_'
          Specifies the prefix for an access type/subtype name. If this
          parameter is set, it overrides for access types the prefix
          set by the `Type' parameter.

    `Class_Access=_string_'
          Specifies the prefix for the name of an access type/subtype
          that points to some class-wide type. If this parameter is
          set, it overrides for such access types and subtypes the
          prefix set by the `Type' or `Access' parameter.

    `Subprogram_Access=_string_'
          Specifies the prefix for the name of an access type/subtype
          that points to a subprogram. If this parameter is set, it
          overrides for such access types/subtypes the prefix set by
          the `Type' or `Access' parameter.

    `Derived=_string1:string2_'
          Specifies the prefix for a type that is directly derived from
          a given type or from a subtype thereof. _string1_ should be a
          full expanded Ada name of the ancestor type (starting from
          the full expanded compilation unit name), _string2_ defines
          the prefix to check. If this parameter is set, it overrides
          for types that are directly derived from the given type the
          prefix set by the `Type' parameter.

    `Constant=_string_'
          Specifies the prefix for defining names from constants and
          named number declarations, including the object renaming
          declaration if the renamed object is a constant

    `Enum=_string_'
          Specifies the prefix for defining enumeration literals and
          for the defining names in a function renaming declarations if
          the renamed entity is an enumeration literal.

    `Exception=_string_'
          Specifies the prefix for defining names from exception
          declarations and exception renaming declarations.

    `Exclusive'
          Check that only those kinds of names for which specific
          prefix is defined have that prefix (e.g., only type/subtype
          names have prefix _T__, but not variable or package names),
          and flag all defining names that have any of the specified
          prefixes but do not belong to the kind of entities this
          prefix is defined for. By default the exclusive check mode is
          ON.

     For the `-R' option:
    `All_Prefixes'
          Removes all the prefixes specified for the identifier prefix
          checks, whether by default or as specified by other rule
          parameters and disables the rule.

    `Type'
          Removes the prefix specified for type/subtype names. This
          does not remove prefixes specified for specific type kinds
          and does not disable checks for these specific kinds.

    `Concurrent'
          Removes the prefix specified for task and protected types.

    `Access'
          Removes the prefix specified for access types. This does not
          remove prefixes specified for specific access types (access
          to subprograms and class-wide access)

    `Class_Access'
          Removes the prefix specified for access types pointing to
          class-wide types.

    `Subprogram_Access'
          Removes the prefix specified for access types pointing to
          subprograms.

    `Derived'
          Removes prefixes specified for derived types that are
          directly derived from specific types.

    `Constant'
          Removes the prefix specified for constant and number names
          and turns off the check for these names.

    `Exception'
          Removes the prefix specified for exception names and turns
          off the check for exception names.

    `Enum'
          Removes the prefix specified for enumeration literal names and
          turns off the check for them.

    `Exclusive'
          Turns of the check that only names of specific kinds of
          entities have prefixes specified for these kinds.

If more than one parameter is used, parameters must be separated by
commas.

   If more than one option is specified for the gnatcheck invocation, a
new option overrides the previous one(s).

   The `+RIdentifier_Prefixes' option (with no parameter) enables checks
for all the name prefixes specified by previous options used for this
rule. If no prefix is specified, the rule is not enabled.

   The `-RIdentifier_Prefixes' option (with no parameter) disables all
the checks but keeps all the prefixes specified by previous options
used for this rule.

   There is no default prefix setting for this rule. All checks for
name prefixes are case-sensitive

   If any error is detected in a rule parameter, that parameter is
ignored.  In such a case the options that are set for the rule are not
specified.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>boolean_relational_operators</key>
    <name>comparisons of Boolean values</name>
    <description>      Flag each call to a predefined relational operator ("&lt;", "&gt;", "&lt;=",
"&gt;=", "=" and "/=") for the predefined Boolean type.  (This rule is
useful in enforcing the SPARK language restrictions.)

   Calls to predefined relational operators of any type derived from
`Standard.Boolean' are not detected.  Calls to user-defined functions
with these designators, and uses of operators that are renamings of the
predefined relational operators for `Standard.Boolean', are likewise
not detected.

   This rule has no parameters.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>implicit_in_mode_parameters</key>
    <name>implicit IN mode in parameter specifications</name>
    <description>      Flag each occurrence of a formal parameter with an implicit `in' mode.
Note that `access' parameters, although they technically behave like
`in' parameters, are not flagged.

   This rule has no parameters.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>positional_components</key>
    <name>positional components associations in aggregates</name>
    <description>      Flag each array, record and extension aggregate that includes positional
notation.

   This rule has no parameters.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>multiple_entries_in_protected_definitions</key>
    <name>protected definitions with more than one entry</name>
    <description>      Flag each protected definition (i.e., each protected object/type
declaration) that defines more than one entry.  Diagnostic messages are
generated for all the entry declarations except the first one. An entry
family is counted as one entry. Entries from the private part of the
protected definition are also checked.

   This rule has no parameters.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>forbidden_pragmas:gnat</key>
    <name>detect all GNAT pragmas except explicitly disabled</name>
    <description>      Flag each use of the specified pragmas.  The pragmas to be detected are
named in the rule's  parameters.

   This rule has the following parameters:

   * For the `+R' option

    _Pragma_Name_
          Adds the specified pragma to the set of pragmas to be checked
          and sets the checks for all the specified pragmas ON.
          _Pragma_Name_ is treated as a name of a pragma. If it does
          not correspond to any pragma name defined in the Ada standard
          or to the name of a GNAT-specific pragma defined in *note
          Implementation Defined Pragmas: (gnat_rm)Implementation
          Defined Pragmas, it is treated as the name of unknown pragma.

    `GNAT'
          All the GNAT-specific pragmas are detected; this sets the
          checks for all the specified pragmas ON.

    `ALL'
          All pragmas are detected; this sets the rule ON.

   * For the `-R' option
    _Pragma_Name_
          Removes the specified pragma from the set of pragmas to be
          checked without affecting checks for other pragmas.
          _Pragma_Name_ is treated as a name of a pragma. If it does
          not correspond to any pragma defined in the Ada standard or
          to any name defined in *note Implementation Defined Pragmas:
          (gnat_rm)Implementation Defined Pragmas, this option is
          treated as turning OFF detection of all unknown pragmas.

    GNAT
          Turn OFF detection of all GNAT-specific pragmas

    ALL
          Clear the list of the pragmas to be detected and turn the
          rule OFF.

Parameters are not case sensitive. If _Pragma_Name_ does not have the
syntax of an Ada identifier and therefore can not be considered as a
pragma name, a diagnostic message is generated and the corresponding
parameter is ignored.

   When more than one parameter is given in the same rule option, the
parameters must be separated by a comma.

   If more than one option for this rule is specified for the
`gnatcheck' call, a new option overrides the previous one(s).

   The `+R' option with no parameters turns the rule ON with the set of
pragmas to be detected defined by the previous rule options.  (By
default this set is empty, so if the only option specified for the rule
is `+RForbidden_Pragmas' (with no parameter), then the rule is enabled,
but it does not detect anything).  The `-R' option with no parameter
turns the rule OFF, but it does not affect the set of pragmas to be
detected.

   Note that in case when the rule is enabled with _ALL_ parameter, then
the rule will flag also pragmas `Annotate' used to exempt rules, see
*note Rule exemption::. Even if you exempt this `Forbidden_Pragmas' rule
then the pragma `Annotate' that closes the exemption section will be
flagged as non-exempted. To avoid this, turn off the check for pragma
`Annotate' by using `-RForbidden_Pragmas:Annotate' rule option.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>identifier_casing:exception</key>
    <name>exception name casing</name>
    <description>      Flag each defining identifier that does not have a casing corresponding
to the kind of entity being declared. All defining names are checked.
For the defining names from the following kinds of declarations a
special casing scheme can be defined:

   * type and subtype declarations;

   * enumeration literal specifications (not including character
     literals) and function renaming declarations if the renaming
     entity is an enumeration literal;

   * constant and number declarations (including object renaming
     declarations if the renamed object is a constant);

   * exception declarations and exception renaming declarations.

   The rule may have the following parameters for `+R':

`Type=_casing_scheme_'
     Specifies casing for names from type and subtype declarations.

`Enum=_casing_scheme_'
     Specifies the casing of defining enumeration literals and for the
     defining names in a function renaming declarations if the renamed
     entity is an enumeration literal.

`Constant=_casing_scheme_'
     Specifies the casing for defining names from constants and named
     number declarations, including the object renaming declaration if
     the renamed object is a constant

`Exception=_casing_scheme_'
     Specifies the casing for names from exception declarations and
     exception renaming declarations.

`Others=_casing_scheme_'
     Specifies the casing for all defining names for which no special
     casing scheme is specified. If this parameter is not set, the
     casing for the entities that do not correspond to the specified
     parameters is not checked.

`Exclude=_dictionary_file_'
     Specifies casing exceptions.

Where:

        casing_scheme ::= upper|lower|mixed

_upper_ means that the defining identifier should be upper-case.
_lower_ means that the defining identifier should be lower-case _mixed_
means that the first defining identifier letter and the first letter
after each underscore should be upper-case, and all the other letters
should be lower-case

   If a defining identifier is from a declaration for which a specific
casing scheme can be set, but the corresponding parameter is not
specified for the rule, then the casing scheme defined by `Others'
parameter is used to check this identifier. If `Others' parameter also
is not set, the identifier is not checked.

   _dictionary_file_ is the name of the text file that contains casing
exceptions. The way how this rule is using the casing exception
dictionary file is consistent with using the casing exception
dictionary in the GNAT pretty-printer `gnatpp', see `GNAT Pro User's
Guide'.

   There are two kinds of exceptions:

_identifier_
     If a dictionary file contains an identifier, then each occurrence
     of that (defining) identifier in the checked source should use the
     casing specified included in _dictionary_file_

_wildcard_
     A wildcard has the following syntax

            WILDCARD ::= *SIMPLE_IDENTIFIER* |
                               *SIMPLE_IDENTIFIER |
                               SIMPLE_IDENTIFIER*
            SIMPLE_IDENTIFIER ::= LETTER{LETTER_OR_DIGIT}

     `simple_identifier' specifies the casing of subwords (the term
     "subword" is used below to denote the part of a name which is
     delimited by "_" or by the beginning or end of the word and which
     does not contain any "_" inside).  A wildcard of the form
     `simple_identifier*' defines the casing of the first subword of a
     defining name to check, the wildcard of the form
     `*simple_identifier' specifies the casing of the last subword, and
     the wildcard of the form `*simple_identifier*' specifies the
     casing of any subword.

     If for a defining identifier some of its subwords can be mapped
     onto wildcards, but some other cannot, the casing of the
     identifier subwords that are not mapped onto wildcards from casing
     exception dictionary is checked against the casing scheme defined
     for the corresponding entity.

   If some identifier is included in the exception dictionary both as a
whole identifier and can be mapped onto some wildcard from the
dictionary, then it is the identifier and not the wildcard that is used
to check the identifier casing.

   If more than one dictionary file is specified, or a dictionary file
contains more than one exception variant for the same identifier, the
new casing exception overrides the previous one.

   Casing check against dictionary file(s) has a higher priority than
checks against the casing scheme specified for a given
entity/declaration kind.

   `+R' option should contain at least one parameter.

   There is no parameter for `-R' option, it just turns the rule off.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>uncommented_begin_in_package_bodies</key>
    <name>BEGIN keywords in package bodies non-marked with comment with package name</name>
    <description>      Flags each package body with declarations and a statement part that
does not include a trailing comment on the line containing the `begin'
keyword; this trailing comment needs to specify the package name and
nothing else.  The `begin' is not flagged if the package body does not
contain any declarations.

   If the `begin' keyword is placed on the same line as the last
declaration or the first statement, it is flagged independently of
whether the line contains a trailing comment. The diagnostic message is
attached to the line containing the first statement.

   This rule has no parameters.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>forbidden_attributes:all</key>
    <name>detect all attributes except explicitly disabled</name>
    <description>      Flag each use of the specified attributes. The attributes to be
detected are named in the rule's parameters.

   This rule has the following parameters:

   * For the `+R' option

    _Attribute_Designator_
          Adds the specified attribute to the set of attributes to be
          detected and sets the detection checks for all the specified
          attributes ON.  If _Attribute_Designator_ does not denote any
          attribute defined in the Ada standard or in *note
          Implementation Defined Attributes: (gnat_rm)Implementation
          Defined Attributes, it is treated as the name of unknown
          attribute.

    `GNAT'
          All the GNAT-specific attributes are detected; this sets the
          detection checks for all the specified attributes ON.

    `ALL'
          All attributes are detected; this sets the rule ON.

   * For the `-R' option
    _Attribute_Designator_
          Removes the specified attribute from the set of attributes to
          be detected without affecting detection checks for other
          attributes. If _Attribute_Designator_ does not correspond to
          any attribute defined in the Ada standard or in *note
          Implementation Defined Attributes: (gnat_rm)Implementation
          Defined Attributes, this option is treated as turning OFF
          detection of all unknown attributes.

    GNAT
          Turn OFF detection of all GNAT-specific attributes

    ALL
          Clear the list of the attributes to be detected and turn the
          rule OFF.

Parameters are not case sensitive. If _Attribute_Designator_ does not
have the syntax of an Ada identifier and therefore can not be
considered as a (part of an) attribute designator, a diagnostic message
is generated and the corresponding parameter is ignored. (If an
attribute allows a static expression to be a part of the attribute
designator, this expression is ignored by this rule.)

   When more than one parameter is given in the same rule option, the
parameters must be separated by commas.

   If more than one option for this rule is specified for the gnatcheck
call, a new option overrides the previous one(s).

   The `+R' option with no parameters turns the rule ON, with the set of
attributes to be detected defined by the previous rule options.  (By
default this set is empty, so if the only option specified for the rule
is `+RForbidden_Attributes' (with no parameter), then the rule is
enabled, but it does not detect anything).  The `-R' option with no
parameter turns the rule OFF, but it does not affect the set of
attributes to be detected.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>forbidden_pragmas:all</key>
    <name>detect all pragmas except explicitly disabled</name>
    <description>      Flag each use of the specified pragmas.  The pragmas to be detected are
named in the rule's  parameters.

   This rule has the following parameters:

   * For the `+R' option

    _Pragma_Name_
          Adds the specified pragma to the set of pragmas to be checked
          and sets the checks for all the specified pragmas ON.
          _Pragma_Name_ is treated as a name of a pragma. If it does
          not correspond to any pragma name defined in the Ada standard
          or to the name of a GNAT-specific pragma defined in *note
          Implementation Defined Pragmas: (gnat_rm)Implementation
          Defined Pragmas, it is treated as the name of unknown pragma.

    `GNAT'
          All the GNAT-specific pragmas are detected; this sets the
          checks for all the specified pragmas ON.

    `ALL'
          All pragmas are detected; this sets the rule ON.

   * For the `-R' option
    _Pragma_Name_
          Removes the specified pragma from the set of pragmas to be
          checked without affecting checks for other pragmas.
          _Pragma_Name_ is treated as a name of a pragma. If it does
          not correspond to any pragma defined in the Ada standard or
          to any name defined in *note Implementation Defined Pragmas:
          (gnat_rm)Implementation Defined Pragmas, this option is
          treated as turning OFF detection of all unknown pragmas.

    GNAT
          Turn OFF detection of all GNAT-specific pragmas

    ALL
          Clear the list of the pragmas to be detected and turn the
          rule OFF.

Parameters are not case sensitive. If _Pragma_Name_ does not have the
syntax of an Ada identifier and therefore can not be considered as a
pragma name, a diagnostic message is generated and the corresponding
parameter is ignored.

   When more than one parameter is given in the same rule option, the
parameters must be separated by a comma.

   If more than one option for this rule is specified for the
`gnatcheck' call, a new option overrides the previous one(s).

   The `+R' option with no parameters turns the rule ON with the set of
pragmas to be detected defined by the previous rule options.  (By
default this set is empty, so if the only option specified for the rule
is `+RForbidden_Pragmas' (with no parameter), then the rule is enabled,
but it does not detect anything).  The `-R' option with no parameter
turns the rule OFF, but it does not affect the set of pragmas to be
detected.

   Note that in case when the rule is enabled with _ALL_ parameter, then
the rule will flag also pragmas `Annotate' used to exempt rules, see
*note Rule exemption::. Even if you exempt this `Forbidden_Pragmas' rule
then the pragma `Annotate' that closes the exemption section will be
flagged as non-exempted. To avoid this, turn off the check for pragma
`Annotate' by using `-RForbidden_Pragmas:Annotate' rule option.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>identifier_casing:enum</key>
    <name>enumeration literal casing</name>
    <description>      Flag each defining identifier that does not have a casing corresponding
to the kind of entity being declared. All defining names are checked.
For the defining names from the following kinds of declarations a
special casing scheme can be defined:

   * type and subtype declarations;

   * enumeration literal specifications (not including character
     literals) and function renaming declarations if the renaming
     entity is an enumeration literal;

   * constant and number declarations (including object renaming
     declarations if the renamed object is a constant);

   * exception declarations and exception renaming declarations.

   The rule may have the following parameters for `+R':

`Type=_casing_scheme_'
     Specifies casing for names from type and subtype declarations.

`Enum=_casing_scheme_'
     Specifies the casing of defining enumeration literals and for the
     defining names in a function renaming declarations if the renamed
     entity is an enumeration literal.

`Constant=_casing_scheme_'
     Specifies the casing for defining names from constants and named
     number declarations, including the object renaming declaration if
     the renamed object is a constant

`Exception=_casing_scheme_'
     Specifies the casing for names from exception declarations and
     exception renaming declarations.

`Others=_casing_scheme_'
     Specifies the casing for all defining names for which no special
     casing scheme is specified. If this parameter is not set, the
     casing for the entities that do not correspond to the specified
     parameters is not checked.

`Exclude=_dictionary_file_'
     Specifies casing exceptions.

Where:

        casing_scheme ::= upper|lower|mixed

_upper_ means that the defining identifier should be upper-case.
_lower_ means that the defining identifier should be lower-case _mixed_
means that the first defining identifier letter and the first letter
after each underscore should be upper-case, and all the other letters
should be lower-case

   If a defining identifier is from a declaration for which a specific
casing scheme can be set, but the corresponding parameter is not
specified for the rule, then the casing scheme defined by `Others'
parameter is used to check this identifier. If `Others' parameter also
is not set, the identifier is not checked.

   _dictionary_file_ is the name of the text file that contains casing
exceptions. The way how this rule is using the casing exception
dictionary file is consistent with using the casing exception
dictionary in the GNAT pretty-printer `gnatpp', see `GNAT Pro User's
Guide'.

   There are two kinds of exceptions:

_identifier_
     If a dictionary file contains an identifier, then each occurrence
     of that (defining) identifier in the checked source should use the
     casing specified included in _dictionary_file_

_wildcard_
     A wildcard has the following syntax

            WILDCARD ::= *SIMPLE_IDENTIFIER* |
                               *SIMPLE_IDENTIFIER |
                               SIMPLE_IDENTIFIER*
            SIMPLE_IDENTIFIER ::= LETTER{LETTER_OR_DIGIT}

     `simple_identifier' specifies the casing of subwords (the term
     "subword" is used below to denote the part of a name which is
     delimited by "_" or by the beginning or end of the word and which
     does not contain any "_" inside).  A wildcard of the form
     `simple_identifier*' defines the casing of the first subword of a
     defining name to check, the wildcard of the form
     `*simple_identifier' specifies the casing of the last subword, and
     the wildcard of the form `*simple_identifier*' specifies the
     casing of any subword.

     If for a defining identifier some of its subwords can be mapped
     onto wildcards, but some other cannot, the casing of the
     identifier subwords that are not mapped onto wildcards from casing
     exception dictionary is checked against the casing scheme defined
     for the corresponding entity.

   If some identifier is included in the exception dictionary both as a
whole identifier and can be mapped onto some wildcard from the
dictionary, then it is the identifier and not the wildcard that is used
to check the identifier casing.

   If more than one dictionary file is specified, or a dictionary file
contains more than one exception variant for the same identifier, the
new casing exception overrides the previous one.

   Casing check against dictionary file(s) has a higher priority than
checks against the casing scheme specified for a given
entity/declaration kind.

   `+R' option should contain at least one parameter.

   There is no parameter for `-R' option, it just turns the rule off.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>declarations_in_blocks</key>
    <name>block statements with local declarations</name>
    <description>      Flag all block statements containing local declarations. A `declare'
block with an empty declarative_part or with a declarative part
containing only pragmas and/or `use' clauses is not flagged.

   This rule has no parameters.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>unnamed_blocks_and_loops</key>
    <name>compound statements naming</name>
    <description>      Flag each unnamed block statement and loop statement.

   The rule has no parameters.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>positional_actuals_for_defaulted_parameters</key>
    <name>positional actuals for defaulted parameters</name>
    <description>      Flag each actual parameter to a subprogram or entry call where the
corresponding formal parameter has a default expression, if positional
notation is used.

   This rule has no parameters.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>non_tagged_derived_types</key>
    <name>derived types that are not type extensions</name>
    <description>      Flag all derived type declarations that do not have a record extension
part.

   This rule has no parameters.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>enumeration_ranges_in_case_statements</key>
    <name>enumeration ranges as choices in case statements</name>
    <description>      Flag each use of a range of enumeration literals as a choice in a
`case' statement.  All forms for specifying a range (explicit ranges
such as `A .. B', subtype marks and `'Range' attributes) are flagged.
An enumeration range is flagged even if contains exactly one
enumeration value or no values at all. A type derived from an
enumeration type is considered as an enumeration type.

   This rule helps prevent maintenance problems arising from adding an
enumeration value to a type and having it implicitly handled by an
existing `case' statement with an enumeration range that includes the
new literal.

   This rule has no parameters.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>outer_loop_exits</key>
    <name>exiting more than one loop at once</name>
    <description>      Flag each `exit' statement containing a loop name that is not the name
of the immediately enclosing `loop' statement.

   This rule has no parameters.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>misnamed_controlling_parameters</key>
    <name>Badly formatted profile of a primitive operation</name>
    <description>      Flag a declaration of a dispatching operation, if the first parameter is
not a controlling one and its name is not `This' (the check for
parameter name is not case-sensitive). Declarations of dispatching
functions with a controlling result and no controlling parameter are
never flagged.

   A subprogram body declaration, subprogram renaming declaration, or
subprogram body stub is flagged only if it is not a completion of a
prior subprogram declaration.

   This rule has no parameters.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>forbidden_pragmas</key>
    <name>do not detect specified pragmas (use ',' as separator)</name>
    <description>      Flag each use of the specified pragmas.  The pragmas to be detected are
named in the rule's  parameters.

   This rule has the following parameters:

   * For the `+R' option

    _Pragma_Name_
          Adds the specified pragma to the set of pragmas to be checked
          and sets the checks for all the specified pragmas ON.
          _Pragma_Name_ is treated as a name of a pragma. If it does
          not correspond to any pragma name defined in the Ada standard
          or to the name of a GNAT-specific pragma defined in *note
          Implementation Defined Pragmas: (gnat_rm)Implementation
          Defined Pragmas, it is treated as the name of unknown pragma.

    `GNAT'
          All the GNAT-specific pragmas are detected; this sets the
          checks for all the specified pragmas ON.

    `ALL'
          All pragmas are detected; this sets the rule ON.

   * For the `-R' option
    _Pragma_Name_
          Removes the specified pragma from the set of pragmas to be
          checked without affecting checks for other pragmas.
          _Pragma_Name_ is treated as a name of a pragma. If it does
          not correspond to any pragma defined in the Ada standard or
          to any name defined in *note Implementation Defined Pragmas:
          (gnat_rm)Implementation Defined Pragmas, this option is
          treated as turning OFF detection of all unknown pragmas.

    GNAT
          Turn OFF detection of all GNAT-specific pragmas

    ALL
          Clear the list of the pragmas to be detected and turn the
          rule OFF.

Parameters are not case sensitive. If _Pragma_Name_ does not have the
syntax of an Ada identifier and therefore can not be considered as a
pragma name, a diagnostic message is generated and the corresponding
parameter is ignored.

   When more than one parameter is given in the same rule option, the
parameters must be separated by a comma.

   If more than one option for this rule is specified for the
`gnatcheck' call, a new option overrides the previous one(s).

   The `+R' option with no parameters turns the rule ON with the set of
pragmas to be detected defined by the previous rule options.  (By
default this set is empty, so if the only option specified for the rule
is `+RForbidden_Pragmas' (with no parameter), then the rule is enabled,
but it does not detect anything).  The `-R' option with no parameter
turns the rule OFF, but it does not affect the set of pragmas to be
detected.

   Note that in case when the rule is enabled with _ALL_ parameter, then
the rule will flag also pragmas `Annotate' used to exempt rules, see
*note Rule exemption::. Even if you exempt this `Forbidden_Pragmas' rule
then the pragma `Annotate' that closes the exemption section will be
flagged as non-exempted. To avoid this, turn off the check for pragma
`Annotate' by using `-RForbidden_Pragmas:Annotate' rule option.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>identifier_prefixes:exclusive</key>
    <name>strong check mode</name>
    <description>      Flag each defining identifier that does not have a prefix corresponding
to the kind of declaration it is defined by. The defining names in the
following kinds of declarations are checked:

   * type and subtype declarations (task, protected and access types
     are treated separately);

   * enumeration literal specifications (not including character
     literals) and function renaming declarations if the renaming
     entity is an enumeration literal;

   * exception declarations and exception renaming declarations;

   * constant and number declarations (including object renaming
     declarations if the renamed object is a constant).

Defining names declared by single task declarations or single protected
declarations are not checked by this rule.

   The defining name from the full type declaration corresponding to a
private type declaration or a private extension declaration is never
flagged. A defining name from an incomplete type declaration is never
flagged.

   The defining name from a subprogram renaming-as-body declaration is
never flagged.

   For a deferred constant, the defining name in the corresponding full
constant declaration is never flagged.

   The defining name from a body that is a completion of a program unit
declaration or a proper body of a subunit is never flagged.

   The defining name from a body stub that is a completion of a program
unit declaration is never flagged.

   Note that the rule checks only defining names. Usage name occurrence
are not checked and are never flagged.

   The rule may have the following parameters:

   * For the `+R' option:
    `Type=_string_'
          Specifies the prefix for a type or subtype name.

    `Concurrent=_string_'
          Specifies the prefix for a task and protected type/subtype
          name. If this parameter is set, it overrides for task and
          protected types the prefix set by the Type parameter.

    `Access=_string_'
          Specifies the prefix for an access type/subtype name. If this
          parameter is set, it overrides for access types the prefix
          set by the `Type' parameter.

    `Class_Access=_string_'
          Specifies the prefix for the name of an access type/subtype
          that points to some class-wide type. If this parameter is
          set, it overrides for such access types and subtypes the
          prefix set by the `Type' or `Access' parameter.

    `Subprogram_Access=_string_'
          Specifies the prefix for the name of an access type/subtype
          that points to a subprogram. If this parameter is set, it
          overrides for such access types/subtypes the prefix set by
          the `Type' or `Access' parameter.

    `Derived=_string1:string2_'
          Specifies the prefix for a type that is directly derived from
          a given type or from a subtype thereof. _string1_ should be a
          full expanded Ada name of the ancestor type (starting from
          the full expanded compilation unit name), _string2_ defines
          the prefix to check. If this parameter is set, it overrides
          for types that are directly derived from the given type the
          prefix set by the `Type' parameter.

    `Constant=_string_'
          Specifies the prefix for defining names from constants and
          named number declarations, including the object renaming
          declaration if the renamed object is a constant

    `Enum=_string_'
          Specifies the prefix for defining enumeration literals and
          for the defining names in a function renaming declarations if
          the renamed entity is an enumeration literal.

    `Exception=_string_'
          Specifies the prefix for defining names from exception
          declarations and exception renaming declarations.

    `Exclusive'
          Check that only those kinds of names for which specific
          prefix is defined have that prefix (e.g., only type/subtype
          names have prefix _T__, but not variable or package names),
          and flag all defining names that have any of the specified
          prefixes but do not belong to the kind of entities this
          prefix is defined for. By default the exclusive check mode is
          ON.

     For the `-R' option:
    `All_Prefixes'
          Removes all the prefixes specified for the identifier prefix
          checks, whether by default or as specified by other rule
          parameters and disables the rule.

    `Type'
          Removes the prefix specified for type/subtype names. This
          does not remove prefixes specified for specific type kinds
          and does not disable checks for these specific kinds.

    `Concurrent'
          Removes the prefix specified for task and protected types.

    `Access'
          Removes the prefix specified for access types. This does not
          remove prefixes specified for specific access types (access
          to subprograms and class-wide access)

    `Class_Access'
          Removes the prefix specified for access types pointing to
          class-wide types.

    `Subprogram_Access'
          Removes the prefix specified for access types pointing to
          subprograms.

    `Derived'
          Removes prefixes specified for derived types that are
          directly derived from specific types.

    `Constant'
          Removes the prefix specified for constant and number names
          and turns off the check for these names.

    `Exception'
          Removes the prefix specified for exception names and turns
          off the check for exception names.

    `Enum'
          Removes the prefix specified for enumeration literal names and
          turns off the check for them.

    `Exclusive'
          Turns of the check that only names of specific kinds of
          entities have prefixes specified for these kinds.

If more than one parameter is used, parameters must be separated by
commas.

   If more than one option is specified for the gnatcheck invocation, a
new option overrides the previous one(s).

   The `+RIdentifier_Prefixes' option (with no parameter) enables checks
for all the name prefixes specified by previous options used for this
rule. If no prefix is specified, the rule is not enabled.

   The `-RIdentifier_Prefixes' option (with no parameter) disables all
the checks but keeps all the prefixes specified by previous options
used for this rule.

   There is no default prefix setting for this rule. All checks for
name prefixes are case-sensitive

   If any error is detected in a rule parameter, that parameter is
ignored.  In such a case the options that are set for the rule are not
specified.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>direct_calls_to_primitives</key>
    <name>non-dispatching calls to primitives</name>
    <description>      Flag any non-dispatching call to a dispatching primitive operation,
except for :

   * a call to the corresponding primitive of the type's immediate
     ancestor.  (This occurs in the common idiom where a primitive
     subprogram for a tagged type directly calls the same primitive
     subprogram of the type's immediate ancestor.)

   * a call to a primitive of an untagged private type, even though the
     full type may be tagged, when the call is made at a place where
     the view of the type is untagged.


   This rule has the following (optional) parameters for the `+R'
option:

_Except_Constructors_
     Do not flag non-dispatching calls to functions if the function has
     a controlling result and no controlling parameters (in a
     traditional OO sense such functions may be considered as
     constructors)</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>complex_inlined_subprograms</key>
    <name>complex inlined subprograms</name>
    <description>      Flag a subprogram (or generic subprogram, or instantiation of a
subprogram) if pragma Inline is applied to it and at least one of the
following conditions is met:

   * it contains at least one complex declaration such as a subprogram
     body, package, task, protected declaration, or a generic
     instantiation (except instantiation of `Ada.Unchecked_Conversion');

   * it contains at least one complex statement such as a loop, a case
     or an if statement;

   * the number of statements exceeds a value specified by the `N' rule
     parameter;
   Subprogram renamings shall also been considered.

This rule has the following (mandatory) parameter for the `+R' option:

_N_
     Positive integer specifying the maximum allowed total number of
     statements in the subprogram body.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>identifier_suffixes:default</key>
    <name>identifiers use standard suffixes</name>
    <description>      Flag the declaration of each identifier that does not have a suffix
corresponding to the kind of entity being declared.  The following
declarations are checked:

   * type declarations

   * subtype declarations

   * constant declarations (but not number declarations)

   * package renaming declarations (but not generic package renaming
     declarations)

This rule may have parameters. When used without parameters, the rule
enforces the following checks:

   * type-defining names end with `_T', unless the type is an access
     type, in which case the suffix must be `_A'

   * constant names end with `_C'

   * names defining package renamings end with `_R'

Defining identifiers from incomplete type declarations are never
flagged.

   For a private type declaration (including private extensions), the
defining identifier from the private type declaration is checked
against the type suffix (even if the corresponding full declaration is
an access type declaration), and the defining identifier from the
corresponding full type declaration is not checked.

For a deferred constant, the defining name in the corresponding full
constant declaration is not checked.

   Defining names of formal types are not checked.

   The rule may have the following parameters:

   * For the `+R' option: unless the parameter is `Default', then only
     the explicitly specified suffix is checked, and no defaults are
     used.
    `Default'
          Sets the default listed above for all the names to be checked.

    `Type_Suffix=_string_'
          Specifies the suffix for a type name.

    `Access_Suffix=_string_'
          Specifies the suffix for an access type name. If this
          parameter is set, it overrides for access types the suffix
          set by the `Type_Suffix' parameter.  For access types,
          _string_ may have the following format: _suffix1(suffix2)_.
          That means that an access type name should have the _suffix1_
          suffix except for the case when the designated type is also
          an access type, in this case the type name should have the
          _suffix1 &amp; suffix2_ suffix.

    `Class_Access_Suffix=_string_'
          Specifies the suffix for the name of an access type that
          points to some class-wide type.  If this parameter is set, it
          overrides for such access types the suffix set by the
          `Type_Suffix' or `Access_Suffix' parameter.

    `Class_Subtype_Suffix=_string_'
          Specifies the suffix for the name of a subtype that denotes a
          class-wide type.

    `Constant_Suffix=_string_'
          Specifies the suffix for a constant name.

    `Renaming_Suffix=_string_'
          Specifies the suffix for a package renaming name.

   * For the `-R' option:
    `All_Suffixes'
          Remove all the suffixes specified for the identifier suffix
          checks, whether by default or as specified by other rule
          parameters. All the checks for this rule are disabled as a
          result.

    `Type_Suffix'
          Removes the suffix specified for types. This disables checks
          for types but does not disable any other checks for this rule
          (including the check for access type names if `Access_Suffix'
          is set).

    `Access_Suffix'
          Removes the suffix specified for access types.  This disables
          checks for access type names but does not disable any other
          checks for this rule.  If `Type_Suffix' is set, access type
          names are checked as ordinary type names.

    `Class_Access_Suffix'
          Removes the suffix specified for access types pointing to
          class-wide type. This disables specific checks for names of
          access types pointing to class-wide types but does not
          disable any other checks for this rule.  If `Type_Suffix' is
          set, access type names are checked as ordinary type names. If
          `Access_Suffix' is set, these access types are checked as any
          other access type name.

    `Class_Subtype_Suffix=_string_'
          Removes the suffix specified for subtype names.  This
          disables checks for subtype names but does not disable any
          other checks for this rule.

    `Constant_Suffix'
          Removes the suffix specified for constants. This disables
          checks for constant names but does not disable any other
          checks for this rule.

    `Renaming_Suffix'
          Removes the suffix specified for package renamings. This
          disables checks for package renamings but does not disable
          any other checks for this rule.

If more than one parameter is used, parameters must be separated by
commas.

   If more than one  option is specified for the `gnatcheck' invocation,
a new option overrides the previous one(s).

   The `+RIdentifier_Suffixes' option (with no parameter) enables
checks for all the name suffixes specified by previous options used for
this rule.

   The `-RIdentifier_Suffixes' option (with no parameter) disables all
the checks but keeps all the suffixes specified by previous options
used for this rule.

   The _string_ value must be a valid suffix for an Ada identifier
(after trimming all the leading and trailing space characters, if any).
Parameters are not case sensitive, except the _string_ part.

   If any error is detected in a rule parameter, the parameter is
ignored.  In such a case the options that are set for the rule are not
specified.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>identifier_suffixes:type_suffix</key>
    <name>suffix for type names (empty string disables check)</name>
    <description>      Flag the declaration of each identifier that does not have a suffix
corresponding to the kind of entity being declared.  The following
declarations are checked:

   * type declarations

   * subtype declarations

   * constant declarations (but not number declarations)

   * package renaming declarations (but not generic package renaming
     declarations)

This rule may have parameters. When used without parameters, the rule
enforces the following checks:

   * type-defining names end with `_T', unless the type is an access
     type, in which case the suffix must be `_A'

   * constant names end with `_C'

   * names defining package renamings end with `_R'

Defining identifiers from incomplete type declarations are never
flagged.

   For a private type declaration (including private extensions), the
defining identifier from the private type declaration is checked
against the type suffix (even if the corresponding full declaration is
an access type declaration), and the defining identifier from the
corresponding full type declaration is not checked.

For a deferred constant, the defining name in the corresponding full
constant declaration is not checked.

   Defining names of formal types are not checked.

   The rule may have the following parameters:

   * For the `+R' option: unless the parameter is `Default', then only
     the explicitly specified suffix is checked, and no defaults are
     used.
    `Default'
          Sets the default listed above for all the names to be checked.

    `Type_Suffix=_string_'
          Specifies the suffix for a type name.

    `Access_Suffix=_string_'
          Specifies the suffix for an access type name. If this
          parameter is set, it overrides for access types the suffix
          set by the `Type_Suffix' parameter.  For access types,
          _string_ may have the following format: _suffix1(suffix2)_.
          That means that an access type name should have the _suffix1_
          suffix except for the case when the designated type is also
          an access type, in this case the type name should have the
          _suffix1 &amp; suffix2_ suffix.

    `Class_Access_Suffix=_string_'
          Specifies the suffix for the name of an access type that
          points to some class-wide type.  If this parameter is set, it
          overrides for such access types the suffix set by the
          `Type_Suffix' or `Access_Suffix' parameter.

    `Class_Subtype_Suffix=_string_'
          Specifies the suffix for the name of a subtype that denotes a
          class-wide type.

    `Constant_Suffix=_string_'
          Specifies the suffix for a constant name.

    `Renaming_Suffix=_string_'
          Specifies the suffix for a package renaming name.

   * For the `-R' option:
    `All_Suffixes'
          Remove all the suffixes specified for the identifier suffix
          checks, whether by default or as specified by other rule
          parameters. All the checks for this rule are disabled as a
          result.

    `Type_Suffix'
          Removes the suffix specified for types. This disables checks
          for types but does not disable any other checks for this rule
          (including the check for access type names if `Access_Suffix'
          is set).

    `Access_Suffix'
          Removes the suffix specified for access types.  This disables
          checks for access type names but does not disable any other
          checks for this rule.  If `Type_Suffix' is set, access type
          names are checked as ordinary type names.

    `Class_Access_Suffix'
          Removes the suffix specified for access types pointing to
          class-wide type. This disables specific checks for names of
          access types pointing to class-wide types but does not
          disable any other checks for this rule.  If `Type_Suffix' is
          set, access type names are checked as ordinary type names. If
          `Access_Suffix' is set, these access types are checked as any
          other access type name.

    `Class_Subtype_Suffix=_string_'
          Removes the suffix specified for subtype names.  This
          disables checks for subtype names but does not disable any
          other checks for this rule.

    `Constant_Suffix'
          Removes the suffix specified for constants. This disables
          checks for constant names but does not disable any other
          checks for this rule.

    `Renaming_Suffix'
          Removes the suffix specified for package renamings. This
          disables checks for package renamings but does not disable
          any other checks for this rule.

If more than one parameter is used, parameters must be separated by
commas.

   If more than one  option is specified for the `gnatcheck' invocation,
a new option overrides the previous one(s).

   The `+RIdentifier_Suffixes' option (with no parameter) enables
checks for all the name suffixes specified by previous options used for
this rule.

   The `-RIdentifier_Suffixes' option (with no parameter) disables all
the checks but keeps all the suffixes specified by previous options
used for this rule.

   The _string_ value must be a valid suffix for an Ada identifier
(after trimming all the leading and trailing space characters, if any).
Parameters are not case sensitive, except the _string_ part.

   If any error is detected in a rule parameter, the parameter is
ignored.  In such a case the options that are set for the rule are not
specified.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>anonymous_arrays</key>
    <name>anonymous array types</name>
    <description>      Flag all anonymous array type definitions (by Ada semantics these can
only occur in object declarations).

   This rule has no parameters.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>positional_actuals_for_defaulted_generic_parameters</key>
    <name>positional generic actuals for defaulted generic parameters</name>
    <description>      Flag each generic actual parameter corresponding to a generic formal
parameter with a default initialization, if positional notation is used.

   This rule has no parameters.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>identifier_suffixes:constant_suffix</key>
    <name>suffix for constant names (empty string disables check)</name>
    <description>      Flag the declaration of each identifier that does not have a suffix
corresponding to the kind of entity being declared.  The following
declarations are checked:

   * type declarations

   * subtype declarations

   * constant declarations (but not number declarations)

   * package renaming declarations (but not generic package renaming
     declarations)

This rule may have parameters. When used without parameters, the rule
enforces the following checks:

   * type-defining names end with `_T', unless the type is an access
     type, in which case the suffix must be `_A'

   * constant names end with `_C'

   * names defining package renamings end with `_R'

Defining identifiers from incomplete type declarations are never
flagged.

   For a private type declaration (including private extensions), the
defining identifier from the private type declaration is checked
against the type suffix (even if the corresponding full declaration is
an access type declaration), and the defining identifier from the
corresponding full type declaration is not checked.

For a deferred constant, the defining name in the corresponding full
constant declaration is not checked.

   Defining names of formal types are not checked.

   The rule may have the following parameters:

   * For the `+R' option: unless the parameter is `Default', then only
     the explicitly specified suffix is checked, and no defaults are
     used.
    `Default'
          Sets the default listed above for all the names to be checked.

    `Type_Suffix=_string_'
          Specifies the suffix for a type name.

    `Access_Suffix=_string_'
          Specifies the suffix for an access type name. If this
          parameter is set, it overrides for access types the suffix
          set by the `Type_Suffix' parameter.  For access types,
          _string_ may have the following format: _suffix1(suffix2)_.
          That means that an access type name should have the _suffix1_
          suffix except for the case when the designated type is also
          an access type, in this case the type name should have the
          _suffix1 &amp; suffix2_ suffix.

    `Class_Access_Suffix=_string_'
          Specifies the suffix for the name of an access type that
          points to some class-wide type.  If this parameter is set, it
          overrides for such access types the suffix set by the
          `Type_Suffix' or `Access_Suffix' parameter.

    `Class_Subtype_Suffix=_string_'
          Specifies the suffix for the name of a subtype that denotes a
          class-wide type.

    `Constant_Suffix=_string_'
          Specifies the suffix for a constant name.

    `Renaming_Suffix=_string_'
          Specifies the suffix for a package renaming name.

   * For the `-R' option:
    `All_Suffixes'
          Remove all the suffixes specified for the identifier suffix
          checks, whether by default or as specified by other rule
          parameters. All the checks for this rule are disabled as a
          result.

    `Type_Suffix'
          Removes the suffix specified for types. This disables checks
          for types but does not disable any other checks for this rule
          (including the check for access type names if `Access_Suffix'
          is set).

    `Access_Suffix'
          Removes the suffix specified for access types.  This disables
          checks for access type names but does not disable any other
          checks for this rule.  If `Type_Suffix' is set, access type
          names are checked as ordinary type names.

    `Class_Access_Suffix'
          Removes the suffix specified for access types pointing to
          class-wide type. This disables specific checks for names of
          access types pointing to class-wide types but does not
          disable any other checks for this rule.  If `Type_Suffix' is
          set, access type names are checked as ordinary type names. If
          `Access_Suffix' is set, these access types are checked as any
          other access type name.

    `Class_Subtype_Suffix=_string_'
          Removes the suffix specified for subtype names.  This
          disables checks for subtype names but does not disable any
          other checks for this rule.

    `Constant_Suffix'
          Removes the suffix specified for constants. This disables
          checks for constant names but does not disable any other
          checks for this rule.

    `Renaming_Suffix'
          Removes the suffix specified for package renamings. This
          disables checks for package renamings but does not disable
          any other checks for this rule.

If more than one parameter is used, parameters must be separated by
commas.

   If more than one  option is specified for the `gnatcheck' invocation,
a new option overrides the previous one(s).

   The `+RIdentifier_Suffixes' option (with no parameter) enables
checks for all the name suffixes specified by previous options used for
this rule.

   The `-RIdentifier_Suffixes' option (with no parameter) disables all
the checks but keeps all the suffixes specified by previous options
used for this rule.

   The _string_ value must be a valid suffix for an Ada identifier
(after trimming all the leading and trailing space characters, if any).
Parameters are not case sensitive, except the _string_ part.

   If any error is detected in a rule parameter, the parameter is
ignored.  In such a case the options that are set for the rule are not
specified.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>library_level_subprograms</key>
    <name>library level subprograms</name>
    <description>      Flag all library-level subprograms (including generic subprogram
instantiations).

   This rule has no parameters.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>separate_numeric_error_handlers</key>
    <name>Numeric_Error and Constraint error are not handled together</name>
    <description>      Flags each exception handler that contains a choice for the predefined
`Constraint_Error' exception, but does not contain the choice for the
predefined `Numeric_Error' exception, or that contains the choice for
`Numeric_Error', but does not contain the choice for `Constraint_Error'.

   This rule has no parameters.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>identifier_casing:others</key>
    <name>other name casing</name>
    <description>      Flag each defining identifier that does not have a casing corresponding
to the kind of entity being declared. All defining names are checked.
For the defining names from the following kinds of declarations a
special casing scheme can be defined:

   * type and subtype declarations;

   * enumeration literal specifications (not including character
     literals) and function renaming declarations if the renaming
     entity is an enumeration literal;

   * constant and number declarations (including object renaming
     declarations if the renamed object is a constant);

   * exception declarations and exception renaming declarations.

   The rule may have the following parameters for `+R':

`Type=_casing_scheme_'
     Specifies casing for names from type and subtype declarations.

`Enum=_casing_scheme_'
     Specifies the casing of defining enumeration literals and for the
     defining names in a function renaming declarations if the renamed
     entity is an enumeration literal.

`Constant=_casing_scheme_'
     Specifies the casing for defining names from constants and named
     number declarations, including the object renaming declaration if
     the renamed object is a constant

`Exception=_casing_scheme_'
     Specifies the casing for names from exception declarations and
     exception renaming declarations.

`Others=_casing_scheme_'
     Specifies the casing for all defining names for which no special
     casing scheme is specified. If this parameter is not set, the
     casing for the entities that do not correspond to the specified
     parameters is not checked.

`Exclude=_dictionary_file_'
     Specifies casing exceptions.

Where:

        casing_scheme ::= upper|lower|mixed

_upper_ means that the defining identifier should be upper-case.
_lower_ means that the defining identifier should be lower-case _mixed_
means that the first defining identifier letter and the first letter
after each underscore should be upper-case, and all the other letters
should be lower-case

   If a defining identifier is from a declaration for which a specific
casing scheme can be set, but the corresponding parameter is not
specified for the rule, then the casing scheme defined by `Others'
parameter is used to check this identifier. If `Others' parameter also
is not set, the identifier is not checked.

   _dictionary_file_ is the name of the text file that contains casing
exceptions. The way how this rule is using the casing exception
dictionary file is consistent with using the casing exception
dictionary in the GNAT pretty-printer `gnatpp', see `GNAT Pro User's
Guide'.

   There are two kinds of exceptions:

_identifier_
     If a dictionary file contains an identifier, then each occurrence
     of that (defining) identifier in the checked source should use the
     casing specified included in _dictionary_file_

_wildcard_
     A wildcard has the following syntax

            WILDCARD ::= *SIMPLE_IDENTIFIER* |
                               *SIMPLE_IDENTIFIER |
                               SIMPLE_IDENTIFIER*
            SIMPLE_IDENTIFIER ::= LETTER{LETTER_OR_DIGIT}

     `simple_identifier' specifies the casing of subwords (the term
     "subword" is used below to denote the part of a name which is
     delimited by "_" or by the beginning or end of the word and which
     does not contain any "_" inside).  A wildcard of the form
     `simple_identifier*' defines the casing of the first subword of a
     defining name to check, the wildcard of the form
     `*simple_identifier' specifies the casing of the last subword, and
     the wildcard of the form `*simple_identifier*' specifies the
     casing of any subword.

     If for a defining identifier some of its subwords can be mapped
     onto wildcards, but some other cannot, the casing of the
     identifier subwords that are not mapped onto wildcards from casing
     exception dictionary is checked against the casing scheme defined
     for the corresponding entity.

   If some identifier is included in the exception dictionary both as a
whole identifier and can be mapped onto some wildcard from the
dictionary, then it is the identifier and not the wildcard that is used
to check the identifier casing.

   If more than one dictionary file is specified, or a dictionary file
contains more than one exception variant for the same identifier, the
new casing exception overrides the previous one.

   Casing check against dictionary file(s) has a higher priority than
checks against the casing scheme specified for a given
entity/declaration kind.

   `+R' option should contain at least one parameter.

   There is no parameter for `-R' option, it just turns the rule off.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>no_scalar_storage_order_specified</key>
    <name>a record/record extension type has record representation clause but no Scalar_Storage_Order attribute clause</name>
    <description>      Flag each record type declaration, record extension declaration, and
untagged derived record type declaration if a
record_representation_clause that has at least one component clause
applies to it (or an ancestor), but neither the type nor any of its
ancestors has an explicitly specified Scalar_Storage_Order attribute.

   This rule has no parameters.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>identifier_prefixes:concurrent</key>
    <name>prefix for task and protected type names (empty string disables check)</name>
    <description>      Flag each defining identifier that does not have a prefix corresponding
to the kind of declaration it is defined by. The defining names in the
following kinds of declarations are checked:

   * type and subtype declarations (task, protected and access types
     are treated separately);

   * enumeration literal specifications (not including character
     literals) and function renaming declarations if the renaming
     entity is an enumeration literal;

   * exception declarations and exception renaming declarations;

   * constant and number declarations (including object renaming
     declarations if the renamed object is a constant).

Defining names declared by single task declarations or single protected
declarations are not checked by this rule.

   The defining name from the full type declaration corresponding to a
private type declaration or a private extension declaration is never
flagged. A defining name from an incomplete type declaration is never
flagged.

   The defining name from a subprogram renaming-as-body declaration is
never flagged.

   For a deferred constant, the defining name in the corresponding full
constant declaration is never flagged.

   The defining name from a body that is a completion of a program unit
declaration or a proper body of a subunit is never flagged.

   The defining name from a body stub that is a completion of a program
unit declaration is never flagged.

   Note that the rule checks only defining names. Usage name occurrence
are not checked and are never flagged.

   The rule may have the following parameters:

   * For the `+R' option:
    `Type=_string_'
          Specifies the prefix for a type or subtype name.

    `Concurrent=_string_'
          Specifies the prefix for a task and protected type/subtype
          name. If this parameter is set, it overrides for task and
          protected types the prefix set by the Type parameter.

    `Access=_string_'
          Specifies the prefix for an access type/subtype name. If this
          parameter is set, it overrides for access types the prefix
          set by the `Type' parameter.

    `Class_Access=_string_'
          Specifies the prefix for the name of an access type/subtype
          that points to some class-wide type. If this parameter is
          set, it overrides for such access types and subtypes the
          prefix set by the `Type' or `Access' parameter.

    `Subprogram_Access=_string_'
          Specifies the prefix for the name of an access type/subtype
          that points to a subprogram. If this parameter is set, it
          overrides for such access types/subtypes the prefix set by
          the `Type' or `Access' parameter.

    `Derived=_string1:string2_'
          Specifies the prefix for a type that is directly derived from
          a given type or from a subtype thereof. _string1_ should be a
          full expanded Ada name of the ancestor type (starting from
          the full expanded compilation unit name), _string2_ defines
          the prefix to check. If this parameter is set, it overrides
          for types that are directly derived from the given type the
          prefix set by the `Type' parameter.

    `Constant=_string_'
          Specifies the prefix for defining names from constants and
          named number declarations, including the object renaming
          declaration if the renamed object is a constant

    `Enum=_string_'
          Specifies the prefix for defining enumeration literals and
          for the defining names in a function renaming declarations if
          the renamed entity is an enumeration literal.

    `Exception=_string_'
          Specifies the prefix for defining names from exception
          declarations and exception renaming declarations.

    `Exclusive'
          Check that only those kinds of names for which specific
          prefix is defined have that prefix (e.g., only type/subtype
          names have prefix _T__, but not variable or package names),
          and flag all defining names that have any of the specified
          prefixes but do not belong to the kind of entities this
          prefix is defined for. By default the exclusive check mode is
          ON.

     For the `-R' option:
    `All_Prefixes'
          Removes all the prefixes specified for the identifier prefix
          checks, whether by default or as specified by other rule
          parameters and disables the rule.

    `Type'
          Removes the prefix specified for type/subtype names. This
          does not remove prefixes specified for specific type kinds
          and does not disable checks for these specific kinds.

    `Concurrent'
          Removes the prefix specified for task and protected types.

    `Access'
          Removes the prefix specified for access types. This does not
          remove prefixes specified for specific access types (access
          to subprograms and class-wide access)

    `Class_Access'
          Removes the prefix specified for access types pointing to
          class-wide types.

    `Subprogram_Access'
          Removes the prefix specified for access types pointing to
          subprograms.

    `Derived'
          Removes prefixes specified for derived types that are
          directly derived from specific types.

    `Constant'
          Removes the prefix specified for constant and number names
          and turns off the check for these names.

    `Exception'
          Removes the prefix specified for exception names and turns
          off the check for exception names.

    `Enum'
          Removes the prefix specified for enumeration literal names and
          turns off the check for them.

    `Exclusive'
          Turns of the check that only names of specific kinds of
          entities have prefixes specified for these kinds.

If more than one parameter is used, parameters must be separated by
commas.

   If more than one option is specified for the gnatcheck invocation, a
new option overrides the previous one(s).

   The `+RIdentifier_Prefixes' option (with no parameter) enables checks
for all the name prefixes specified by previous options used for this
rule. If no prefix is specified, the rule is not enabled.

   The `-RIdentifier_Prefixes' option (with no parameter) disables all
the checks but keeps all the prefixes specified by previous options
used for this rule.

   There is no default prefix setting for this rule. All checks for
name prefixes are case-sensitive

   If any error is detected in a rule parameter, that parameter is
ignored.  In such a case the options that are set for the rule are not
specified.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>others_in_case_statements</key>
    <name>OTHERS choices in case statements</name>
    <description>      Flag any use of an `others' choice in a `case' statement.

   This rule has no parameters.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>goto_statements</key>
    <name>goto statements</name>
    <description>      Flag each occurrence of a `goto' statement.

   This rule has no parameters.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>predefined_numeric_types</key>
    <name>explicit references to predefined numeric subtypes</name>
    <description>      Flag each explicit use of the name of any numeric type or subtype
defined in package `Standard'.

   The rationale for this rule is to detect when the program may depend
on platform-specific characteristics of the implementation of the
predefined numeric types. Note that this rule is overly pessimistic;
for example, a program that uses `String' indexing likely needs a
variable of type `Integer'.  Another example is the flagging of
predefined numeric types with explicit constraints:

         subtype My_Integer is Integer range Left .. Right;
         Vy_Var : My_Integer;

This rule detects only numeric types and subtypes defined in
`Standard'. The use of numeric types and subtypes defined in other
predefined packages (such as `System.Any_Priority' or
`Ada.Text_IO.Count') is not flagged

   This rule has no parameters.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>annotated_comments</key>
    <name>detect specified annotations (use ',' as separator)</name>
    <description>      Flags comments that are used as annotations or as special
sentinels/markers. Such comments have the following structure

       --&lt;special_character&gt; &lt;comment_marker&gt;

where

`&lt;special_character&gt;'
     character (such as '#', '$', '|' etc.) indicating that the comment
     is used for a specific purpose

`&lt;comment_marker&gt;'
     a word identifying the annotation or special usage (word here is
     any sequence of characters except white space)

There may be any amount of white space (including none at all) between
`&lt;special_character&gt;' and `&lt;comment_marker&gt;', but no white space is
permitted between `'--'' and `&lt;special_character&gt;'. (A white space here
is either a space character or horizontal tabulation)

   `&lt;comment_marker&gt;' must not contain any white space.

   `&lt;comment_marker&gt;' may be empty, in which case the rule flags each
comment that starts with `--&lt;special_character&gt;' and that does not
contain any other character except white space

   The rule has the following (mandatory) parameter for the `+R' option:

_S_
     String with the following interpretation: the first character is
     the special comment character, and the rest is the comment marker.
     S must not contain white space.

The `-R' option erases all definitions of special comment annotations
specified by the previous +R options.

   The rule is case-sensitive.

   Example:

   The rule

     +RAnnotated_Comments:#hide

will flag the following comment lines

     --#hide
     --# hide
     --#           hide

        I := I + 1; --# hide

But the line

     -- # hide

will not be flagged, because of the space between '-' and '#'.

   The line

     --#Hide

will not be flagged, because the string parameter is case sensitive.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>exits_from_conditional_loops</key>
    <name>exit from conditional loops</name>
    <description>      Flag any exit statement if it transfers the control out of a `for' loop
or a `while' loop. This includes cases when the `exit' statement
applies to a `FOR' or `while' loop, and cases when it is enclosed in
some `for' or `while' loop, but transfers the control from some outer
(unconditional) `loop' statement.

   The rule has no parameters.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>implicit_small_for_fixed_point_types</key>
    <name>fixed point type declarations with no 'Small clause</name>
    <description>      Flag each fixed point type declaration that lacks an explicit
representation  clause to define its `'Small' value.  Since `'Small'
can be  defined only for ordinary fixed point types, decimal fixed
point type declarations are not checked.

   This rule has no parameters.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>float_equality_checks</key>
    <name>equality for float values</name>
    <description>      Flag all calls to the predefined equality operations for floating-point
types.  Both "`='" and "`/='" operations are checked.  User-defined
equality operations are not flagged, nor are uses of operators that are
renamings of the predefined equality operations.  Also, the "`='" and
"`/='" operations for fixed-point types are not flagged.

   This rule has no parameters.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>discriminated_records</key>
    <name>discriminated records</name>
    <description>      Flag all declarations of record types with discriminants. Only the
declarations of record and record extension types are checked.
Incomplete, formal, private, derived and private extension type
declarations are not checked. Task and protected type declarations also
are not checked.

   This rule has no parameters.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>slices</key>
    <name>slices</name>
    <description>      Flag all uses of array slicing

   This rule has no parameters.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>identifier_prefixes:constant</key>
    <name>prefix for constant names (empty string disables check)</name>
    <description>      Flag each defining identifier that does not have a prefix corresponding
to the kind of declaration it is defined by. The defining names in the
following kinds of declarations are checked:

   * type and subtype declarations (task, protected and access types
     are treated separately);

   * enumeration literal specifications (not including character
     literals) and function renaming declarations if the renaming
     entity is an enumeration literal;

   * exception declarations and exception renaming declarations;

   * constant and number declarations (including object renaming
     declarations if the renamed object is a constant).

Defining names declared by single task declarations or single protected
declarations are not checked by this rule.

   The defining name from the full type declaration corresponding to a
private type declaration or a private extension declaration is never
flagged. A defining name from an incomplete type declaration is never
flagged.

   The defining name from a subprogram renaming-as-body declaration is
never flagged.

   For a deferred constant, the defining name in the corresponding full
constant declaration is never flagged.

   The defining name from a body that is a completion of a program unit
declaration or a proper body of a subunit is never flagged.

   The defining name from a body stub that is a completion of a program
unit declaration is never flagged.

   Note that the rule checks only defining names. Usage name occurrence
are not checked and are never flagged.

   The rule may have the following parameters:

   * For the `+R' option:
    `Type=_string_'
          Specifies the prefix for a type or subtype name.

    `Concurrent=_string_'
          Specifies the prefix for a task and protected type/subtype
          name. If this parameter is set, it overrides for task and
          protected types the prefix set by the Type parameter.

    `Access=_string_'
          Specifies the prefix for an access type/subtype name. If this
          parameter is set, it overrides for access types the prefix
          set by the `Type' parameter.

    `Class_Access=_string_'
          Specifies the prefix for the name of an access type/subtype
          that points to some class-wide type. If this parameter is
          set, it overrides for such access types and subtypes the
          prefix set by the `Type' or `Access' parameter.

    `Subprogram_Access=_string_'
          Specifies the prefix for the name of an access type/subtype
          that points to a subprogram. If this parameter is set, it
          overrides for such access types/subtypes the prefix set by
          the `Type' or `Access' parameter.

    `Derived=_string1:string2_'
          Specifies the prefix for a type that is directly derived from
          a given type or from a subtype thereof. _string1_ should be a
          full expanded Ada name of the ancestor type (starting from
          the full expanded compilation unit name), _string2_ defines
          the prefix to check. If this parameter is set, it overrides
          for types that are directly derived from the given type the
          prefix set by the `Type' parameter.

    `Constant=_string_'
          Specifies the prefix for defining names from constants and
          named number declarations, including the object renaming
          declaration if the renamed object is a constant

    `Enum=_string_'
          Specifies the prefix for defining enumeration literals and
          for the defining names in a function renaming declarations if
          the renamed entity is an enumeration literal.

    `Exception=_string_'
          Specifies the prefix for defining names from exception
          declarations and exception renaming declarations.

    `Exclusive'
          Check that only those kinds of names for which specific
          prefix is defined have that prefix (e.g., only type/subtype
          names have prefix _T__, but not variable or package names),
          and flag all defining names that have any of the specified
          prefixes but do not belong to the kind of entities this
          prefix is defined for. By default the exclusive check mode is
          ON.

     For the `-R' option:
    `All_Prefixes'
          Removes all the prefixes specified for the identifier prefix
          checks, whether by default or as specified by other rule
          parameters and disables the rule.

    `Type'
          Removes the prefix specified for type/subtype names. This
          does not remove prefixes specified for specific type kinds
          and does not disable checks for these specific kinds.

    `Concurrent'
          Removes the prefix specified for task and protected types.

    `Access'
          Removes the prefix specified for access types. This does not
          remove prefixes specified for specific access types (access
          to subprograms and class-wide access)

    `Class_Access'
          Removes the prefix specified for access types pointing to
          class-wide types.

    `Subprogram_Access'
          Removes the prefix specified for access types pointing to
          subprograms.

    `Derived'
          Removes prefixes specified for derived types that are
          directly derived from specific types.

    `Constant'
          Removes the prefix specified for constant and number names
          and turns off the check for these names.

    `Exception'
          Removes the prefix specified for exception names and turns
          off the check for exception names.

    `Enum'
          Removes the prefix specified for enumeration literal names and
          turns off the check for them.

    `Exclusive'
          Turns of the check that only names of specific kinds of
          entities have prefixes specified for these kinds.

If more than one parameter is used, parameters must be separated by
commas.

   If more than one option is specified for the gnatcheck invocation, a
new option overrides the previous one(s).

   The `+RIdentifier_Prefixes' option (with no parameter) enables checks
for all the name prefixes specified by previous options used for this
rule. If no prefix is specified, the rule is not enabled.

   The `-RIdentifier_Prefixes' option (with no parameter) disables all
the checks but keeps all the prefixes specified by previous options
used for this rule.

   There is no default prefix setting for this rule. All checks for
name prefixes are case-sensitive

   If any error is detected in a rule parameter, that parameter is
ignored.  In such a case the options that are set for the rule are not
specified.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>abstract_type_declarations</key>
    <name>abstract types</name>
    <description>      Flag all declarations of abstract types. For an abstract private type,
both the private and full type declarations are flagged.

   This rule has no parameters.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>overly_nested_control_structures</key>
    <name>deep nesting level of control structures</name>
    <description>      Flag each control structure whose nesting level exceeds the value
provided in the rule parameter.

   The control structures checked are the following:

   * `if' statement

   * `case' statement

   * `loop' statement

   * selective accept statement

   * timed entry call statement

   * conditional entry call statement

   * asynchronous select statement

The rule has the following parameter for the `+R' option:

_N_
     Positive integer specifying the maximal control structure nesting
     level that is not flagged

If the parameter for the `+R' option is not specified or if it is not a
positive integer, `+R' option is ignored.

   If more than one  option is specified for the gnatcheck call, the
later option and new parameter override the previous one(s).</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>metrics_lsloc</key>
    <name>(metrics) high LSLOC value</name>
    <description>      The `Metrics_LSLOC' rule takes a positive integer as upper bound.  A
program unit declaration or a program unit body exceeding this limit
will be flagged.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>identifier_prefixes:derived</key>
    <name>prefix for derived type names (empty string disables check)</name>
    <description>      Flag each defining identifier that does not have a prefix corresponding
to the kind of declaration it is defined by. The defining names in the
following kinds of declarations are checked:

   * type and subtype declarations (task, protected and access types
     are treated separately);

   * enumeration literal specifications (not including character
     literals) and function renaming declarations if the renaming
     entity is an enumeration literal;

   * exception declarations and exception renaming declarations;

   * constant and number declarations (including object renaming
     declarations if the renamed object is a constant).

Defining names declared by single task declarations or single protected
declarations are not checked by this rule.

   The defining name from the full type declaration corresponding to a
private type declaration or a private extension declaration is never
flagged. A defining name from an incomplete type declaration is never
flagged.

   The defining name from a subprogram renaming-as-body declaration is
never flagged.

   For a deferred constant, the defining name in the corresponding full
constant declaration is never flagged.

   The defining name from a body that is a completion of a program unit
declaration or a proper body of a subunit is never flagged.

   The defining name from a body stub that is a completion of a program
unit declaration is never flagged.

   Note that the rule checks only defining names. Usage name occurrence
are not checked and are never flagged.

   The rule may have the following parameters:

   * For the `+R' option:
    `Type=_string_'
          Specifies the prefix for a type or subtype name.

    `Concurrent=_string_'
          Specifies the prefix for a task and protected type/subtype
          name. If this parameter is set, it overrides for task and
          protected types the prefix set by the Type parameter.

    `Access=_string_'
          Specifies the prefix for an access type/subtype name. If this
          parameter is set, it overrides for access types the prefix
          set by the `Type' parameter.

    `Class_Access=_string_'
          Specifies the prefix for the name of an access type/subtype
          that points to some class-wide type. If this parameter is
          set, it overrides for such access types and subtypes the
          prefix set by the `Type' or `Access' parameter.

    `Subprogram_Access=_string_'
          Specifies the prefix for the name of an access type/subtype
          that points to a subprogram. If this parameter is set, it
          overrides for such access types/subtypes the prefix set by
          the `Type' or `Access' parameter.

    `Derived=_string1:string2_'
          Specifies the prefix for a type that is directly derived from
          a given type or from a subtype thereof. _string1_ should be a
          full expanded Ada name of the ancestor type (starting from
          the full expanded compilation unit name), _string2_ defines
          the prefix to check. If this parameter is set, it overrides
          for types that are directly derived from the given type the
          prefix set by the `Type' parameter.

    `Constant=_string_'
          Specifies the prefix for defining names from constants and
          named number declarations, including the object renaming
          declaration if the renamed object is a constant

    `Enum=_string_'
          Specifies the prefix for defining enumeration literals and
          for the defining names in a function renaming declarations if
          the renamed entity is an enumeration literal.

    `Exception=_string_'
          Specifies the prefix for defining names from exception
          declarations and exception renaming declarations.

    `Exclusive'
          Check that only those kinds of names for which specific
          prefix is defined have that prefix (e.g., only type/subtype
          names have prefix _T__, but not variable or package names),
          and flag all defining names that have any of the specified
          prefixes but do not belong to the kind of entities this
          prefix is defined for. By default the exclusive check mode is
          ON.

     For the `-R' option:
    `All_Prefixes'
          Removes all the prefixes specified for the identifier prefix
          checks, whether by default or as specified by other rule
          parameters and disables the rule.

    `Type'
          Removes the prefix specified for type/subtype names. This
          does not remove prefixes specified for specific type kinds
          and does not disable checks for these specific kinds.

    `Concurrent'
          Removes the prefix specified for task and protected types.

    `Access'
          Removes the prefix specified for access types. This does not
          remove prefixes specified for specific access types (access
          to subprograms and class-wide access)

    `Class_Access'
          Removes the prefix specified for access types pointing to
          class-wide types.

    `Subprogram_Access'
          Removes the prefix specified for access types pointing to
          subprograms.

    `Derived'
          Removes prefixes specified for derived types that are
          directly derived from specific types.

    `Constant'
          Removes the prefix specified for constant and number names
          and turns off the check for these names.

    `Exception'
          Removes the prefix specified for exception names and turns
          off the check for exception names.

    `Enum'
          Removes the prefix specified for enumeration literal names and
          turns off the check for them.

    `Exclusive'
          Turns of the check that only names of specific kinds of
          entities have prefixes specified for these kinds.

If more than one parameter is used, parameters must be separated by
commas.

   If more than one option is specified for the gnatcheck invocation, a
new option overrides the previous one(s).

   The `+RIdentifier_Prefixes' option (with no parameter) enables checks
for all the name prefixes specified by previous options used for this
rule. If no prefix is specified, the rule is not enabled.

   The `-RIdentifier_Prefixes' option (with no parameter) disables all
the checks but keeps all the prefixes specified by previous options
used for this rule.

   There is no default prefix setting for this rule. All checks for
name prefixes are case-sensitive

   If any error is detected in a rule parameter, that parameter is
ignored.  In such a case the options that are set for the rule are not
specified.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>explicit_full_discrete_ranges</key>
    <name>explicit discrete ranges</name>
    <description>      Flag each discrete range that has the form `A'First .. A'Last'.

   This rule has no parameters.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>volatile_objects_without_address_clauses</key>
    <name>volatile objects with no address clause</name>
    <description>      Flag each volatile object that does not have an address clause.

   The following check is made: if the pragma `Volatile' is applied to a
data object or to its type, then an address clause must be supplied for
this object.

   This rule does not check the components of data objects, array
components that are volatile as a result of the pragma
`Volatile_Components', or objects that are volatile because they are
atomic as a result of pragmas `Atomic' or `Atomic_Components'.

   Only variable declarations, and not constant declarations, are
checked.

   This rule has no parameters.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>local_packages</key>
    <name>local packages</name>
    <description>      Flag all local packages declared in package and generic package specs.
Local packages in bodies are not flagged.

   This rule has no parameters.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>expanded_loop_exit_names</key>
    <name>expanded loop names in exit statements</name>
    <description>      Flag all expanded loop names in `exit' statements.

   This rule has no parameters.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>visible_components</key>
    <name>Types with publicly accessible components</name>
    <description>      Flag all the type declarations located in the visible part of a library
package or a library generic package that can declare a visible
component.  A visible component can be declared in a record definition
which appears on its own or as part of a record extension.  The record
definition is flagged even if it contains no components.

   Record definitions located in private parts of library (generic)
packages or in local (generic) packages are not flagged. Record
definitions in private packages, in package bodies, and in the main
subprogram body are not flagged.

   This rule has no parameters.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>raising_external_exceptions</key>
    <name>visibility of exceptions raised by routines declared in library package</name>
    <description>      Flag any `raise' statement, in a program unit declared in a library
package or in a generic library package, for an exception that is
neither a predefined exception nor an exception that is also declared
(or renamed) in the visible part of the package.

   This rule has no parameters.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>identifier_casing:type</key>
    <name>type name casing</name>
    <description>      Flag each defining identifier that does not have a casing corresponding
to the kind of entity being declared. All defining names are checked.
For the defining names from the following kinds of declarations a
special casing scheme can be defined:

   * type and subtype declarations;

   * enumeration literal specifications (not including character
     literals) and function renaming declarations if the renaming
     entity is an enumeration literal;

   * constant and number declarations (including object renaming
     declarations if the renamed object is a constant);

   * exception declarations and exception renaming declarations.

   The rule may have the following parameters for `+R':

`Type=_casing_scheme_'
     Specifies casing for names from type and subtype declarations.

`Enum=_casing_scheme_'
     Specifies the casing of defining enumeration literals and for the
     defining names in a function renaming declarations if the renamed
     entity is an enumeration literal.

`Constant=_casing_scheme_'
     Specifies the casing for defining names from constants and named
     number declarations, including the object renaming declaration if
     the renamed object is a constant

`Exception=_casing_scheme_'
     Specifies the casing for names from exception declarations and
     exception renaming declarations.

`Others=_casing_scheme_'
     Specifies the casing for all defining names for which no special
     casing scheme is specified. If this parameter is not set, the
     casing for the entities that do not correspond to the specified
     parameters is not checked.

`Exclude=_dictionary_file_'
     Specifies casing exceptions.

Where:

        casing_scheme ::= upper|lower|mixed

_upper_ means that the defining identifier should be upper-case.
_lower_ means that the defining identifier should be lower-case _mixed_
means that the first defining identifier letter and the first letter
after each underscore should be upper-case, and all the other letters
should be lower-case

   If a defining identifier is from a declaration for which a specific
casing scheme can be set, but the corresponding parameter is not
specified for the rule, then the casing scheme defined by `Others'
parameter is used to check this identifier. If `Others' parameter also
is not set, the identifier is not checked.

   _dictionary_file_ is the name of the text file that contains casing
exceptions. The way how this rule is using the casing exception
dictionary file is consistent with using the casing exception
dictionary in the GNAT pretty-printer `gnatpp', see `GNAT Pro User's
Guide'.

   There are two kinds of exceptions:

_identifier_
     If a dictionary file contains an identifier, then each occurrence
     of that (defining) identifier in the checked source should use the
     casing specified included in _dictionary_file_

_wildcard_
     A wildcard has the following syntax

            WILDCARD ::= *SIMPLE_IDENTIFIER* |
                               *SIMPLE_IDENTIFIER |
                               SIMPLE_IDENTIFIER*
            SIMPLE_IDENTIFIER ::= LETTER{LETTER_OR_DIGIT}

     `simple_identifier' specifies the casing of subwords (the term
     "subword" is used below to denote the part of a name which is
     delimited by "_" or by the beginning or end of the word and which
     does not contain any "_" inside).  A wildcard of the form
     `simple_identifier*' defines the casing of the first subword of a
     defining name to check, the wildcard of the form
     `*simple_identifier' specifies the casing of the last subword, and
     the wildcard of the form `*simple_identifier*' specifies the
     casing of any subword.

     If for a defining identifier some of its subwords can be mapped
     onto wildcards, but some other cannot, the casing of the
     identifier subwords that are not mapped onto wildcards from casing
     exception dictionary is checked against the casing scheme defined
     for the corresponding entity.

   If some identifier is included in the exception dictionary both as a
whole identifier and can be mapped onto some wildcard from the
dictionary, then it is the identifier and not the wildcard that is used
to check the identifier casing.

   If more than one dictionary file is specified, or a dictionary file
contains more than one exception variant for the same identifier, the
new casing exception overrides the previous one.

   Casing check against dictionary file(s) has a higher priority than
checks against the casing scheme specified for a given
entity/declaration kind.

   `+R' option should contain at least one parameter.

   There is no parameter for `-R' option, it just turns the rule off.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>non_spark_attributes</key>
    <name>attributes that are not from the SPARK subset</name>
    <description>      The SPARK language defines the following subset of Ada 95 attribute
designators as those that can be used in SPARK programs. The use of any
other attribute is flagged.

   * `'Adjacent'

   * `'Aft'

   * `'Base'

   * `'Ceiling'

   * `'Component_Size'

   * `'Compose'

   * `'Copy_Sign'

   * `'Delta'

   * `'Denorm'

   * `'Digits'

   * `'Exponent'

   * `'First'

   * `'Floor'

   * `'Fore'

   * `'Fraction'

   * `'Last'

   * `'Leading_Part'

   * `'Length'

   * `'Machine'

   * `'Machine_Emax'

   * `'Machine_Emin'

   * `'Machine_Mantissa'

   * `'Machine_Overflows'

   * `'Machine_Radix'

   * `'Machine_Rounds'

   * `'Max'

   * `'Min'

   * `'Model'

   * `'Model_Emin'

   * `'Model_Epsilon'

   * `'Model_Mantissa'

   * `'Model_Small'

   * `'Modulus'

   * `'Pos'

   * `'Pred'

   * `'Range'

   * `'Remainder'

   * `'Rounding'

   * `'Safe_First'

   * `'Safe_Last'

   * `'Scaling'

   * `'Signed_Zeros'

   * `'Size'

   * `'Small'

   * `'Succ'

   * `'Truncation'

   * `'Unbiased_Rounding'

   * `'Val'

   * `'Valid'

This rule has no parameters.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>identifier_prefixes:exception</key>
    <name>prefix for exception names (empty string disables check)</name>
    <description>      Flag each defining identifier that does not have a prefix corresponding
to the kind of declaration it is defined by. The defining names in the
following kinds of declarations are checked:

   * type and subtype declarations (task, protected and access types
     are treated separately);

   * enumeration literal specifications (not including character
     literals) and function renaming declarations if the renaming
     entity is an enumeration literal;

   * exception declarations and exception renaming declarations;

   * constant and number declarations (including object renaming
     declarations if the renamed object is a constant).

Defining names declared by single task declarations or single protected
declarations are not checked by this rule.

   The defining name from the full type declaration corresponding to a
private type declaration or a private extension declaration is never
flagged. A defining name from an incomplete type declaration is never
flagged.

   The defining name from a subprogram renaming-as-body declaration is
never flagged.

   For a deferred constant, the defining name in the corresponding full
constant declaration is never flagged.

   The defining name from a body that is a completion of a program unit
declaration or a proper body of a subunit is never flagged.

   The defining name from a body stub that is a completion of a program
unit declaration is never flagged.

   Note that the rule checks only defining names. Usage name occurrence
are not checked and are never flagged.

   The rule may have the following parameters:

   * For the `+R' option:
    `Type=_string_'
          Specifies the prefix for a type or subtype name.

    `Concurrent=_string_'
          Specifies the prefix for a task and protected type/subtype
          name. If this parameter is set, it overrides for task and
          protected types the prefix set by the Type parameter.

    `Access=_string_'
          Specifies the prefix for an access type/subtype name. If this
          parameter is set, it overrides for access types the prefix
          set by the `Type' parameter.

    `Class_Access=_string_'
          Specifies the prefix for the name of an access type/subtype
          that points to some class-wide type. If this parameter is
          set, it overrides for such access types and subtypes the
          prefix set by the `Type' or `Access' parameter.

    `Subprogram_Access=_string_'
          Specifies the prefix for the name of an access type/subtype
          that points to a subprogram. If this parameter is set, it
          overrides for such access types/subtypes the prefix set by
          the `Type' or `Access' parameter.

    `Derived=_string1:string2_'
          Specifies the prefix for a type that is directly derived from
          a given type or from a subtype thereof. _string1_ should be a
          full expanded Ada name of the ancestor type (starting from
          the full expanded compilation unit name), _string2_ defines
          the prefix to check. If this parameter is set, it overrides
          for types that are directly derived from the given type the
          prefix set by the `Type' parameter.

    `Constant=_string_'
          Specifies the prefix for defining names from constants and
          named number declarations, including the object renaming
          declaration if the renamed object is a constant

    `Enum=_string_'
          Specifies the prefix for defining enumeration literals and
          for the defining names in a function renaming declarations if
          the renamed entity is an enumeration literal.

    `Exception=_string_'
          Specifies the prefix for defining names from exception
          declarations and exception renaming declarations.

    `Exclusive'
          Check that only those kinds of names for which specific
          prefix is defined have that prefix (e.g., only type/subtype
          names have prefix _T__, but not variable or package names),
          and flag all defining names that have any of the specified
          prefixes but do not belong to the kind of entities this
          prefix is defined for. By default the exclusive check mode is
          ON.

     For the `-R' option:
    `All_Prefixes'
          Removes all the prefixes specified for the identifier prefix
          checks, whether by default or as specified by other rule
          parameters and disables the rule.

    `Type'
          Removes the prefix specified for type/subtype names. This
          does not remove prefixes specified for specific type kinds
          and does not disable checks for these specific kinds.

    `Concurrent'
          Removes the prefix specified for task and protected types.

    `Access'
          Removes the prefix specified for access types. This does not
          remove prefixes specified for specific access types (access
          to subprograms and class-wide access)

    `Class_Access'
          Removes the prefix specified for access types pointing to
          class-wide types.

    `Subprogram_Access'
          Removes the prefix specified for access types pointing to
          subprograms.

    `Derived'
          Removes prefixes specified for derived types that are
          directly derived from specific types.

    `Constant'
          Removes the prefix specified for constant and number names
          and turns off the check for these names.

    `Exception'
          Removes the prefix specified for exception names and turns
          off the check for exception names.

    `Enum'
          Removes the prefix specified for enumeration literal names and
          turns off the check for them.

    `Exclusive'
          Turns of the check that only names of specific kinds of
          entities have prefixes specified for these kinds.

If more than one parameter is used, parameters must be separated by
commas.

   If more than one option is specified for the gnatcheck invocation, a
new option overrides the previous one(s).

   The `+RIdentifier_Prefixes' option (with no parameter) enables checks
for all the name prefixes specified by previous options used for this
rule. If no prefix is specified, the rule is not enabled.

   The `-RIdentifier_Prefixes' option (with no parameter) disables all
the checks but keeps all the prefixes specified by previous options
used for this rule.

   There is no default prefix setting for this rule. All checks for
name prefixes are case-sensitive

   If any error is detected in a rule parameter, that parameter is
ignored.  In such a case the options that are set for the rule are not
specified.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>positional_generic_parameters</key>
    <name>positional generic associations</name>
    <description>      Flag each positional actual generic parameter except for the case when
the generic unit being instantiated has exactly one generic formal
parameter.

   This rule has no parameters.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>identifier_suffixes:access_suffix</key>
    <name>suffix for access type names  (empty string disables check)</name>
    <description>      Flag the declaration of each identifier that does not have a suffix
corresponding to the kind of entity being declared.  The following
declarations are checked:

   * type declarations

   * subtype declarations

   * constant declarations (but not number declarations)

   * package renaming declarations (but not generic package renaming
     declarations)

This rule may have parameters. When used without parameters, the rule
enforces the following checks:

   * type-defining names end with `_T', unless the type is an access
     type, in which case the suffix must be `_A'

   * constant names end with `_C'

   * names defining package renamings end with `_R'

Defining identifiers from incomplete type declarations are never
flagged.

   For a private type declaration (including private extensions), the
defining identifier from the private type declaration is checked
against the type suffix (even if the corresponding full declaration is
an access type declaration), and the defining identifier from the
corresponding full type declaration is not checked.

For a deferred constant, the defining name in the corresponding full
constant declaration is not checked.

   Defining names of formal types are not checked.

   The rule may have the following parameters:

   * For the `+R' option: unless the parameter is `Default', then only
     the explicitly specified suffix is checked, and no defaults are
     used.
    `Default'
          Sets the default listed above for all the names to be checked.

    `Type_Suffix=_string_'
          Specifies the suffix for a type name.

    `Access_Suffix=_string_'
          Specifies the suffix for an access type name. If this
          parameter is set, it overrides for access types the suffix
          set by the `Type_Suffix' parameter.  For access types,
          _string_ may have the following format: _suffix1(suffix2)_.
          That means that an access type name should have the _suffix1_
          suffix except for the case when the designated type is also
          an access type, in this case the type name should have the
          _suffix1 &amp; suffix2_ suffix.

    `Class_Access_Suffix=_string_'
          Specifies the suffix for the name of an access type that
          points to some class-wide type.  If this parameter is set, it
          overrides for such access types the suffix set by the
          `Type_Suffix' or `Access_Suffix' parameter.

    `Class_Subtype_Suffix=_string_'
          Specifies the suffix for the name of a subtype that denotes a
          class-wide type.

    `Constant_Suffix=_string_'
          Specifies the suffix for a constant name.

    `Renaming_Suffix=_string_'
          Specifies the suffix for a package renaming name.

   * For the `-R' option:
    `All_Suffixes'
          Remove all the suffixes specified for the identifier suffix
          checks, whether by default or as specified by other rule
          parameters. All the checks for this rule are disabled as a
          result.

    `Type_Suffix'
          Removes the suffix specified for types. This disables checks
          for types but does not disable any other checks for this rule
          (including the check for access type names if `Access_Suffix'
          is set).

    `Access_Suffix'
          Removes the suffix specified for access types.  This disables
          checks for access type names but does not disable any other
          checks for this rule.  If `Type_Suffix' is set, access type
          names are checked as ordinary type names.

    `Class_Access_Suffix'
          Removes the suffix specified for access types pointing to
          class-wide type. This disables specific checks for names of
          access types pointing to class-wide types but does not
          disable any other checks for this rule.  If `Type_Suffix' is
          set, access type names are checked as ordinary type names. If
          `Access_Suffix' is set, these access types are checked as any
          other access type name.

    `Class_Subtype_Suffix=_string_'
          Removes the suffix specified for subtype names.  This
          disables checks for subtype names but does not disable any
          other checks for this rule.

    `Constant_Suffix'
          Removes the suffix specified for constants. This disables
          checks for constant names but does not disable any other
          checks for this rule.

    `Renaming_Suffix'
          Removes the suffix specified for package renamings. This
          disables checks for package renamings but does not disable
          any other checks for this rule.

If more than one parameter is used, parameters must be separated by
commas.

   If more than one  option is specified for the `gnatcheck' invocation,
a new option overrides the previous one(s).

   The `+RIdentifier_Suffixes' option (with no parameter) enables
checks for all the name suffixes specified by previous options used for
this rule.

   The `-RIdentifier_Suffixes' option (with no parameter) disables all
the checks but keeps all the suffixes specified by previous options
used for this rule.

   The _string_ value must be a valid suffix for an Ada identifier
(after trimming all the leading and trailing space characters, if any).
Parameters are not case sensitive, except the _string_ part.

   If any error is detected in a rule parameter, the parameter is
ignored.  In such a case the options that are set for the rule are not
specified.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>anonymous_subtypes</key>
    <name>anonymous subtypes</name>
    <description>      Flag all uses of anonymous subtypes (except cases when subtype
indication is a part of a record component definition, and this subtype
indication depends on a discriminant). A use of an anonymous subtype is
any instance of a subtype indication with a constraint, other than one
that occurs immediately within a subtype declaration. Any use of a range
other than as a constraint used immediately within a subtype declaration
is considered as an anonymous subtype.

   The rule does not flag ranges in the component clauses from a record
representation clause, because the language rules do not allow to use
subtype names there.

   An effect of this rule is that `for' loops such as the following are
flagged (since `1..N' is formally a "range"):

     for I in 1 .. N loop
        ...
     end loop;

Declaring an explicit subtype solves the problem:

     subtype S is Integer range 1..N;
     ...
     for I in S loop
        ...
     end loop;

This rule has no parameters.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>identifier_prefixes:access</key>
    <name>prefix for access type names (empty string disables check)</name>
    <description>      Flag each defining identifier that does not have a prefix corresponding
to the kind of declaration it is defined by. The defining names in the
following kinds of declarations are checked:

   * type and subtype declarations (task, protected and access types
     are treated separately);

   * enumeration literal specifications (not including character
     literals) and function renaming declarations if the renaming
     entity is an enumeration literal;

   * exception declarations and exception renaming declarations;

   * constant and number declarations (including object renaming
     declarations if the renamed object is a constant).

Defining names declared by single task declarations or single protected
declarations are not checked by this rule.

   The defining name from the full type declaration corresponding to a
private type declaration or a private extension declaration is never
flagged. A defining name from an incomplete type declaration is never
flagged.

   The defining name from a subprogram renaming-as-body declaration is
never flagged.

   For a deferred constant, the defining name in the corresponding full
constant declaration is never flagged.

   The defining name from a body that is a completion of a program unit
declaration or a proper body of a subunit is never flagged.

   The defining name from a body stub that is a completion of a program
unit declaration is never flagged.

   Note that the rule checks only defining names. Usage name occurrence
are not checked and are never flagged.

   The rule may have the following parameters:

   * For the `+R' option:
    `Type=_string_'
          Specifies the prefix for a type or subtype name.

    `Concurrent=_string_'
          Specifies the prefix for a task and protected type/subtype
          name. If this parameter is set, it overrides for task and
          protected types the prefix set by the Type parameter.

    `Access=_string_'
          Specifies the prefix for an access type/subtype name. If this
          parameter is set, it overrides for access types the prefix
          set by the `Type' parameter.

    `Class_Access=_string_'
          Specifies the prefix for the name of an access type/subtype
          that points to some class-wide type. If this parameter is
          set, it overrides for such access types and subtypes the
          prefix set by the `Type' or `Access' parameter.

    `Subprogram_Access=_string_'
          Specifies the prefix for the name of an access type/subtype
          that points to a subprogram. If this parameter is set, it
          overrides for such access types/subtypes the prefix set by
          the `Type' or `Access' parameter.

    `Derived=_string1:string2_'
          Specifies the prefix for a type that is directly derived from
          a given type or from a subtype thereof. _string1_ should be a
          full expanded Ada name of the ancestor type (starting from
          the full expanded compilation unit name), _string2_ defines
          the prefix to check. If this parameter is set, it overrides
          for types that are directly derived from the given type the
          prefix set by the `Type' parameter.

    `Constant=_string_'
          Specifies the prefix for defining names from constants and
          named number declarations, including the object renaming
          declaration if the renamed object is a constant

    `Enum=_string_'
          Specifies the prefix for defining enumeration literals and
          for the defining names in a function renaming declarations if
          the renamed entity is an enumeration literal.

    `Exception=_string_'
          Specifies the prefix for defining names from exception
          declarations and exception renaming declarations.

    `Exclusive'
          Check that only those kinds of names for which specific
          prefix is defined have that prefix (e.g., only type/subtype
          names have prefix _T__, but not variable or package names),
          and flag all defining names that have any of the specified
          prefixes but do not belong to the kind of entities this
          prefix is defined for. By default the exclusive check mode is
          ON.

     For the `-R' option:
    `All_Prefixes'
          Removes all the prefixes specified for the identifier prefix
          checks, whether by default or as specified by other rule
          parameters and disables the rule.

    `Type'
          Removes the prefix specified for type/subtype names. This
          does not remove prefixes specified for specific type kinds
          and does not disable checks for these specific kinds.

    `Concurrent'
          Removes the prefix specified for task and protected types.

    `Access'
          Removes the prefix specified for access types. This does not
          remove prefixes specified for specific access types (access
          to subprograms and class-wide access)

    `Class_Access'
          Removes the prefix specified for access types pointing to
          class-wide types.

    `Subprogram_Access'
          Removes the prefix specified for access types pointing to
          subprograms.

    `Derived'
          Removes prefixes specified for derived types that are
          directly derived from specific types.

    `Constant'
          Removes the prefix specified for constant and number names
          and turns off the check for these names.

    `Exception'
          Removes the prefix specified for exception names and turns
          off the check for exception names.

    `Enum'
          Removes the prefix specified for enumeration literal names and
          turns off the check for them.

    `Exclusive'
          Turns of the check that only names of specific kinds of
          entities have prefixes specified for these kinds.

If more than one parameter is used, parameters must be separated by
commas.

   If more than one option is specified for the gnatcheck invocation, a
new option overrides the previous one(s).

   The `+RIdentifier_Prefixes' option (with no parameter) enables checks
for all the name prefixes specified by previous options used for this
rule. If no prefix is specified, the rule is not enabled.

   The `-RIdentifier_Prefixes' option (with no parameter) disables all
the checks but keeps all the prefixes specified by previous options
used for this rule.

   There is no default prefix setting for this rule. All checks for
name prefixes are case-sensitive

   If any error is detected in a rule parameter, that parameter is
ignored.  In such a case the options that are set for the rule are not
specified.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>identifier_prefixes:subprogram_access</key>
    <name>prefix for access-to-subprogram type names (empty string disables check)</name>
    <description>      Flag each defining identifier that does not have a prefix corresponding
to the kind of declaration it is defined by. The defining names in the
following kinds of declarations are checked:

   * type and subtype declarations (task, protected and access types
     are treated separately);

   * enumeration literal specifications (not including character
     literals) and function renaming declarations if the renaming
     entity is an enumeration literal;

   * exception declarations and exception renaming declarations;

   * constant and number declarations (including object renaming
     declarations if the renamed object is a constant).

Defining names declared by single task declarations or single protected
declarations are not checked by this rule.

   The defining name from the full type declaration corresponding to a
private type declaration or a private extension declaration is never
flagged. A defining name from an incomplete type declaration is never
flagged.

   The defining name from a subprogram renaming-as-body declaration is
never flagged.

   For a deferred constant, the defining name in the corresponding full
constant declaration is never flagged.

   The defining name from a body that is a completion of a program unit
declaration or a proper body of a subunit is never flagged.

   The defining name from a body stub that is a completion of a program
unit declaration is never flagged.

   Note that the rule checks only defining names. Usage name occurrence
are not checked and are never flagged.

   The rule may have the following parameters:

   * For the `+R' option:
    `Type=_string_'
          Specifies the prefix for a type or subtype name.

    `Concurrent=_string_'
          Specifies the prefix for a task and protected type/subtype
          name. If this parameter is set, it overrides for task and
          protected types the prefix set by the Type parameter.

    `Access=_string_'
          Specifies the prefix for an access type/subtype name. If this
          parameter is set, it overrides for access types the prefix
          set by the `Type' parameter.

    `Class_Access=_string_'
          Specifies the prefix for the name of an access type/subtype
          that points to some class-wide type. If this parameter is
          set, it overrides for such access types and subtypes the
          prefix set by the `Type' or `Access' parameter.

    `Subprogram_Access=_string_'
          Specifies the prefix for the name of an access type/subtype
          that points to a subprogram. If this parameter is set, it
          overrides for such access types/subtypes the prefix set by
          the `Type' or `Access' parameter.

    `Derived=_string1:string2_'
          Specifies the prefix for a type that is directly derived from
          a given type or from a subtype thereof. _string1_ should be a
          full expanded Ada name of the ancestor type (starting from
          the full expanded compilation unit name), _string2_ defines
          the prefix to check. If this parameter is set, it overrides
          for types that are directly derived from the given type the
          prefix set by the `Type' parameter.

    `Constant=_string_'
          Specifies the prefix for defining names from constants and
          named number declarations, including the object renaming
          declaration if the renamed object is a constant

    `Enum=_string_'
          Specifies the prefix for defining enumeration literals and
          for the defining names in a function renaming declarations if
          the renamed entity is an enumeration literal.

    `Exception=_string_'
          Specifies the prefix for defining names from exception
          declarations and exception renaming declarations.

    `Exclusive'
          Check that only those kinds of names for which specific
          prefix is defined have that prefix (e.g., only type/subtype
          names have prefix _T__, but not variable or package names),
          and flag all defining names that have any of the specified
          prefixes but do not belong to the kind of entities this
          prefix is defined for. By default the exclusive check mode is
          ON.

     For the `-R' option:
    `All_Prefixes'
          Removes all the prefixes specified for the identifier prefix
          checks, whether by default or as specified by other rule
          parameters and disables the rule.

    `Type'
          Removes the prefix specified for type/subtype names. This
          does not remove prefixes specified for specific type kinds
          and does not disable checks for these specific kinds.

    `Concurrent'
          Removes the prefix specified for task and protected types.

    `Access'
          Removes the prefix specified for access types. This does not
          remove prefixes specified for specific access types (access
          to subprograms and class-wide access)

    `Class_Access'
          Removes the prefix specified for access types pointing to
          class-wide types.

    `Subprogram_Access'
          Removes the prefix specified for access types pointing to
          subprograms.

    `Derived'
          Removes prefixes specified for derived types that are
          directly derived from specific types.

    `Constant'
          Removes the prefix specified for constant and number names
          and turns off the check for these names.

    `Exception'
          Removes the prefix specified for exception names and turns
          off the check for exception names.

    `Enum'
          Removes the prefix specified for enumeration literal names and
          turns off the check for them.

    `Exclusive'
          Turns of the check that only names of specific kinds of
          entities have prefixes specified for these kinds.

If more than one parameter is used, parameters must be separated by
commas.

   If more than one option is specified for the gnatcheck invocation, a
new option overrides the previous one(s).

   The `+RIdentifier_Prefixes' option (with no parameter) enables checks
for all the name prefixes specified by previous options used for this
rule. If no prefix is specified, the rule is not enabled.

   The `-RIdentifier_Prefixes' option (with no parameter) disables all
the checks but keeps all the prefixes specified by previous options
used for this rule.

   There is no default prefix setting for this rule. All checks for
name prefixes are case-sensitive

   If any error is detected in a rule parameter, that parameter is
ignored.  In such a case the options that are set for the rule are not
specified.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>positional_parameters</key>
    <name>positional associations in subprogram and entry calls</name>
    <description>      Flag each positional parameter notation in a subprogram or entry call,
except for the following:

   * Parameters of calls to of prefix or infix operators are not flagged

   * If the called subprogram or entry has only one formal parameter,
     the parameter of the call is not flagged;

   * If a subprogram call uses the _Object.Operation_ notation, then
        - the first parameter (that is, _Object_) is not flagged;

        - if the called subprogram has only two parameters, the second
          parameter of the call is not flagged;

This rule has no parameters.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>non_qualified_aggregates</key>
    <name>non-qualified aggregates</name>
    <description>      Flag each non-qualified aggregate.  A non-qualified aggregate is an
aggregate that is not the expression of a qualified expression. A
string literal is not considered an aggregate, but an array aggregate
of a string type is considered as a normal aggregate.  Aggregates of
anonymous array types are not flagged.

   This rule has no parameters.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>identifier_prefixes:class_access</key>
    <name>prefix for class access type names (empty string disables check)</name>
    <description>      Flag each defining identifier that does not have a prefix corresponding
to the kind of declaration it is defined by. The defining names in the
following kinds of declarations are checked:

   * type and subtype declarations (task, protected and access types
     are treated separately);

   * enumeration literal specifications (not including character
     literals) and function renaming declarations if the renaming
     entity is an enumeration literal;

   * exception declarations and exception renaming declarations;

   * constant and number declarations (including object renaming
     declarations if the renamed object is a constant).

Defining names declared by single task declarations or single protected
declarations are not checked by this rule.

   The defining name from the full type declaration corresponding to a
private type declaration or a private extension declaration is never
flagged. A defining name from an incomplete type declaration is never
flagged.

   The defining name from a subprogram renaming-as-body declaration is
never flagged.

   For a deferred constant, the defining name in the corresponding full
constant declaration is never flagged.

   The defining name from a body that is a completion of a program unit
declaration or a proper body of a subunit is never flagged.

   The defining name from a body stub that is a completion of a program
unit declaration is never flagged.

   Note that the rule checks only defining names. Usage name occurrence
are not checked and are never flagged.

   The rule may have the following parameters:

   * For the `+R' option:
    `Type=_string_'
          Specifies the prefix for a type or subtype name.

    `Concurrent=_string_'
          Specifies the prefix for a task and protected type/subtype
          name. If this parameter is set, it overrides for task and
          protected types the prefix set by the Type parameter.

    `Access=_string_'
          Specifies the prefix for an access type/subtype name. If this
          parameter is set, it overrides for access types the prefix
          set by the `Type' parameter.

    `Class_Access=_string_'
          Specifies the prefix for the name of an access type/subtype
          that points to some class-wide type. If this parameter is
          set, it overrides for such access types and subtypes the
          prefix set by the `Type' or `Access' parameter.

    `Subprogram_Access=_string_'
          Specifies the prefix for the name of an access type/subtype
          that points to a subprogram. If this parameter is set, it
          overrides for such access types/subtypes the prefix set by
          the `Type' or `Access' parameter.

    `Derived=_string1:string2_'
          Specifies the prefix for a type that is directly derived from
          a given type or from a subtype thereof. _string1_ should be a
          full expanded Ada name of the ancestor type (starting from
          the full expanded compilation unit name), _string2_ defines
          the prefix to check. If this parameter is set, it overrides
          for types that are directly derived from the given type the
          prefix set by the `Type' parameter.

    `Constant=_string_'
          Specifies the prefix for defining names from constants and
          named number declarations, including the object renaming
          declaration if the renamed object is a constant

    `Enum=_string_'
          Specifies the prefix for defining enumeration literals and
          for the defining names in a function renaming declarations if
          the renamed entity is an enumeration literal.

    `Exception=_string_'
          Specifies the prefix for defining names from exception
          declarations and exception renaming declarations.

    `Exclusive'
          Check that only those kinds of names for which specific
          prefix is defined have that prefix (e.g., only type/subtype
          names have prefix _T__, but not variable or package names),
          and flag all defining names that have any of the specified
          prefixes but do not belong to the kind of entities this
          prefix is defined for. By default the exclusive check mode is
          ON.

     For the `-R' option:
    `All_Prefixes'
          Removes all the prefixes specified for the identifier prefix
          checks, whether by default or as specified by other rule
          parameters and disables the rule.

    `Type'
          Removes the prefix specified for type/subtype names. This
          does not remove prefixes specified for specific type kinds
          and does not disable checks for these specific kinds.

    `Concurrent'
          Removes the prefix specified for task and protected types.

    `Access'
          Removes the prefix specified for access types. This does not
          remove prefixes specified for specific access types (access
          to subprograms and class-wide access)

    `Class_Access'
          Removes the prefix specified for access types pointing to
          class-wide types.

    `Subprogram_Access'
          Removes the prefix specified for access types pointing to
          subprograms.

    `Derived'
          Removes prefixes specified for derived types that are
          directly derived from specific types.

    `Constant'
          Removes the prefix specified for constant and number names
          and turns off the check for these names.

    `Exception'
          Removes the prefix specified for exception names and turns
          off the check for exception names.

    `Enum'
          Removes the prefix specified for enumeration literal names and
          turns off the check for them.

    `Exclusive'
          Turns of the check that only names of specific kinds of
          entities have prefixes specified for these kinds.

If more than one parameter is used, parameters must be separated by
commas.

   If more than one option is specified for the gnatcheck invocation, a
new option overrides the previous one(s).

   The `+RIdentifier_Prefixes' option (with no parameter) enables checks
for all the name prefixes specified by previous options used for this
rule. If no prefix is specified, the rule is not enabled.

   The `-RIdentifier_Prefixes' option (with no parameter) disables all
the checks but keeps all the prefixes specified by previous options
used for this rule.

   There is no default prefix setting for this rule. All checks for
name prefixes are case-sensitive

   If any error is detected in a rule parameter, that parameter is
ignored.  In such a case the options that are set for the rule are not
specified.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>others_in_aggregates</key>
    <name>OTHERS choices in aggregates</name>
    <description>      Flag each use of an `others' choice in extension aggregates.  In record
and array aggregates, an `others' choice is flagged unless it is used
to refer to all components, or to all but one component.

   If, in case of a named array aggregate, there are two associations,
one with an `others' choice and another with a discrete range, the
`others' choice is flagged even if the discrete range specifies exactly
one component; for example, `(1..1 =&gt; 0, others =&gt; 1)'.

   This rule has no parameters.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>recursive_subprograms</key>
    <name>recursion (call graph cycles)</name>
    <description>      Flags specs (and bodies that act as specs) of recursive subprograms. A
subprogram is considered as recursive in a given context if there exists
a chain of direct calls starting from the body of, and ending at this
subprogram within this context. A context is provided by the set of Ada
sources specified as arguments of a given gnatcheck call.  Neither
dispatching calls nor calls through access-to-subprograms are
considered as direct calls by this rule.

   Generic subprograms and subprograms detected in generic units are not
flagged. Recursive subprograms in expanded generic instantiations are
flagged.

   This rule has no parameters.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>non_short_circuit_operators</key>
    <name>use of predefined AND and OR for boolean types</name>
    <description>      Flag all calls to predefined `and' and `or' operators for any boolean
type. Calls to user-defined `and' and `or' and to operators defined by
renaming declarations are not flagged. Calls to predefined `and' and
`or' operators for modular types or boolean array types are not flagged.

   This rule has no parameters.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>forbidden_attributes:gnat</key>
    <name>detect all GNAT attributes except explicitly disabled</name>
    <description>      Flag each use of the specified attributes. The attributes to be
detected are named in the rule's parameters.

   This rule has the following parameters:

   * For the `+R' option

    _Attribute_Designator_
          Adds the specified attribute to the set of attributes to be
          detected and sets the detection checks for all the specified
          attributes ON.  If _Attribute_Designator_ does not denote any
          attribute defined in the Ada standard or in *note
          Implementation Defined Attributes: (gnat_rm)Implementation
          Defined Attributes, it is treated as the name of unknown
          attribute.

    `GNAT'
          All the GNAT-specific attributes are detected; this sets the
          detection checks for all the specified attributes ON.

    `ALL'
          All attributes are detected; this sets the rule ON.

   * For the `-R' option
    _Attribute_Designator_
          Removes the specified attribute from the set of attributes to
          be detected without affecting detection checks for other
          attributes. If _Attribute_Designator_ does not correspond to
          any attribute defined in the Ada standard or in *note
          Implementation Defined Attributes: (gnat_rm)Implementation
          Defined Attributes, this option is treated as turning OFF
          detection of all unknown attributes.

    GNAT
          Turn OFF detection of all GNAT-specific attributes

    ALL
          Clear the list of the attributes to be detected and turn the
          rule OFF.

Parameters are not case sensitive. If _Attribute_Designator_ does not
have the syntax of an Ada identifier and therefore can not be
considered as a (part of an) attribute designator, a diagnostic message
is generated and the corresponding parameter is ignored. (If an
attribute allows a static expression to be a part of the attribute
designator, this expression is ignored by this rule.)

   When more than one parameter is given in the same rule option, the
parameters must be separated by commas.

   If more than one option for this rule is specified for the gnatcheck
call, a new option overrides the previous one(s).

   The `+R' option with no parameters turns the rule ON, with the set of
attributes to be detected defined by the previous rule options.  (By
default this set is empty, so if the only option specified for the rule
is `+RForbidden_Attributes' (with no parameter), then the rule is
enabled, but it does not detect anything).  The `-R' option with no
parameter turns the rule OFF, but it does not affect the set of
attributes to be detected.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>numeric_literals</key>
    <name>Checks that no numeric literal is greater than the entered number, or set ALL to check all numeric literals</name>
    <description>      Flag each use of a numeric literal in an index expression, and in any
circumstance except for the following:

   * a literal occurring in the initialization expression for a constant
     declaration or a named number declaration, or

   * an integer literal that is less than or equal to a value specified
     by the `N' rule parameter.

   * a literal occurring in a declaration in case the `Statements_Only'
     rule parameter is given

This rule may have the following parameters for the `+R' option:

_N_
     _N_ is an integer literal used as the maximal value that is not
     flagged (i.e., integer literals not exceeding this value are
     allowed)

`ALL'
     All integer literals are flagged

`Statements_Only'
     Numeric literals are flagged only when used in statements

If no parameters are set, the maximum unflagged value is 1, and the
check for literals is not limited by statements only.

   The last specified check limit (or the fact that there is no limit at
all) is used when multiple `+R' options appear.

   The `-R' option for this rule has no parameters.  It disables the
rule and restores its default operation mode.  If the `+R' option
subsequently appears, will be 1, and the check will not be limited by
statements only.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>generics_in_subprograms</key>
    <name>definitions of generic units in  subprogram bodies</name>
    <description>      Flag each declaration of a generic unit in a subprogram. Generic
declarations in the bodies of generic subprograms are also flagged.  A
generic unit nested in another generic unit is not flagged.  If a
generic unit is declared in a local package that is declared in a
subprogram body, the generic unit is flagged.

   This rule has no parameters.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>universal_ranges</key>
    <name>ranges with universal integer bounds</name>
    <description>      Flag discrete ranges that are a part of an index constraint, constrained
array definition, or `for'-loop parameter specification, and whose
bounds are both of type universal_integer. Ranges that have at least one
bound of a specific type (such as `1 .. N', where `N' is a variable or
an expression of non-universal type) are not flagged.

   This rule has no parameters.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>metrics_essential_complexity</key>
    <name>(metrics) high essential complexity</name>
    <description>      The `Metrics_Essential_Complexity' rule takes a positive integer as
upper bound.  A program unit that is an executable body exceeding this
limit will be flagged.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>non_visible_exceptions</key>
    <name>potential propagations of non-visible exceptions</name>
    <description>      Flag constructs leading to the possibility of propagating an exception
out of the scope in which the exception is declared.  Two cases are
detected:

   * An exception declaration in a subprogram body, task body or block
     statement is flagged if the body or statement does not contain a
     handler for that exception or a handler with an `others' choice.

   * A `raise' statement in an exception handler of a subprogram body,
     task body or block statement is flagged if it (re)raises a locally
     declared exception.  This may occur under the following
     circumstances:
        - it explicitly raises a locally declared exception, or

        - it does not specify an exception name (i.e., it is simply
          `raise;') and the enclosing handler contains a locally
          declared exception in its exception choices.

Renamings of local exceptions are not flagged.

   This rule has no parameters.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>deep_inheritance_hierarchies</key>
    <name>derivation tree is too deep</name>
    <description>      Flags a tagged derived type declaration or an interface type
declaration if its depth (in its inheritance hierarchy) exceeds the
value specified by the `N' rule parameter. Types in generic
instantiations which violate this rule are also flagged; generic formal
types are not flagged. This rule also does not flag private extension
declarations. In the case of a private extension, the corresponding
full declaration is checked.

   In most cases, the inheritance depth of a tagged type or interface
type is defined as 0 for a type with no parent and no progenitor, and
otherwise as 1 + max of the depths of the immediate parent and
immediate progenitors. If the declaration of a formal derived type has
no progenitor, or if the declaration of a formal interface type has
exactly one progenitor, then the inheritance depth of such a formal
derived/interface type is equal to the inheritance depth of its
parent/progenitor type, otherwise the general rule is applied.

   If the rule flags a type declaration inside the generic unit, this
means that this type declaration will be flagged in any instantiation
of the generic unit. But if a type is derived from a format type or has
a formal progenitor and it is not flagged at the place where it is
defined in a generic unit, it may or may not be flagged in
instantiation, this depends of the inheritance depth of the actual
parameters.

   This rule has the following (mandatory) parameter for the `+R'
option:

_N_
     Integer not less than -1 specifying the maximal allowed depth of
     any inheritance hierarchy. If the rule parameter is set to -1, the
     rule flags all the declarations of tagged and interface types.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>use_package_clauses</key>
    <name>use clause for packages</name>
    <description>      Flag all `use' clauses for packages; `use type' clauses are not flagged.

   This rule has no parameters.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>deeply_nested_generics</key>
    <name>deeply nested generic declarations</name>
    <description>      Flag a generic declaration nested in another generic declaration if the
nesting level of the inner generic exceeds the value specified by the
`N' rule parameter.  The nesting level is the number of generic
declarations that enclose the given (generic) declaration. Formal
packages are not flagged by this rule.

   This rule has the following (mandatory) parameters for the `+R'
option:

_N_
     Positive integer specifying the maximum nesting level for a
     generic declaration.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>improper_returns</key>
    <name>improper use of return statements</name>
    <description>      Flag each explicit `return' statement in procedures, and multiple
`return' statements in functions.  Diagnostic messages are generated
for all `return' statements in a procedure (thus each procedure must be
written so that it returns implicitly at the end of its statement part),
and for all `return' statements in a function after the first one.
This rule supports the stylistic convention that each subprogram should
have no more than one point of normal return.

   This rule has no parameters.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>identifier_prefixes:enum</key>
    <name>prefix for enumeration literals (empty string disables check)</name>
    <description>      Flag each defining identifier that does not have a prefix corresponding
to the kind of declaration it is defined by. The defining names in the
following kinds of declarations are checked:

   * type and subtype declarations (task, protected and access types
     are treated separately);

   * enumeration literal specifications (not including character
     literals) and function renaming declarations if the renaming
     entity is an enumeration literal;

   * exception declarations and exception renaming declarations;

   * constant and number declarations (including object renaming
     declarations if the renamed object is a constant).

Defining names declared by single task declarations or single protected
declarations are not checked by this rule.

   The defining name from the full type declaration corresponding to a
private type declaration or a private extension declaration is never
flagged. A defining name from an incomplete type declaration is never
flagged.

   The defining name from a subprogram renaming-as-body declaration is
never flagged.

   For a deferred constant, the defining name in the corresponding full
constant declaration is never flagged.

   The defining name from a body that is a completion of a program unit
declaration or a proper body of a subunit is never flagged.

   The defining name from a body stub that is a completion of a program
unit declaration is never flagged.

   Note that the rule checks only defining names. Usage name occurrence
are not checked and are never flagged.

   The rule may have the following parameters:

   * For the `+R' option:
    `Type=_string_'
          Specifies the prefix for a type or subtype name.

    `Concurrent=_string_'
          Specifies the prefix for a task and protected type/subtype
          name. If this parameter is set, it overrides for task and
          protected types the prefix set by the Type parameter.

    `Access=_string_'
          Specifies the prefix for an access type/subtype name. If this
          parameter is set, it overrides for access types the prefix
          set by the `Type' parameter.

    `Class_Access=_string_'
          Specifies the prefix for the name of an access type/subtype
          that points to some class-wide type. If this parameter is
          set, it overrides for such access types and subtypes the
          prefix set by the `Type' or `Access' parameter.

    `Subprogram_Access=_string_'
          Specifies the prefix for the name of an access type/subtype
          that points to a subprogram. If this parameter is set, it
          overrides for such access types/subtypes the prefix set by
          the `Type' or `Access' parameter.

    `Derived=_string1:string2_'
          Specifies the prefix for a type that is directly derived from
          a given type or from a subtype thereof. _string1_ should be a
          full expanded Ada name of the ancestor type (starting from
          the full expanded compilation unit name), _string2_ defines
          the prefix to check. If this parameter is set, it overrides
          for types that are directly derived from the given type the
          prefix set by the `Type' parameter.

    `Constant=_string_'
          Specifies the prefix for defining names from constants and
          named number declarations, including the object renaming
          declaration if the renamed object is a constant

    `Enum=_string_'
          Specifies the prefix for defining enumeration literals and
          for the defining names in a function renaming declarations if
          the renamed entity is an enumeration literal.

    `Exception=_string_'
          Specifies the prefix for defining names from exception
          declarations and exception renaming declarations.

    `Exclusive'
          Check that only those kinds of names for which specific
          prefix is defined have that prefix (e.g., only type/subtype
          names have prefix _T__, but not variable or package names),
          and flag all defining names that have any of the specified
          prefixes but do not belong to the kind of entities this
          prefix is defined for. By default the exclusive check mode is
          ON.

     For the `-R' option:
    `All_Prefixes'
          Removes all the prefixes specified for the identifier prefix
          checks, whether by default or as specified by other rule
          parameters and disables the rule.

    `Type'
          Removes the prefix specified for type/subtype names. This
          does not remove prefixes specified for specific type kinds
          and does not disable checks for these specific kinds.

    `Concurrent'
          Removes the prefix specified for task and protected types.

    `Access'
          Removes the prefix specified for access types. This does not
          remove prefixes specified for specific access types (access
          to subprograms and class-wide access)

    `Class_Access'
          Removes the prefix specified for access types pointing to
          class-wide types.

    `Subprogram_Access'
          Removes the prefix specified for access types pointing to
          subprograms.

    `Derived'
          Removes prefixes specified for derived types that are
          directly derived from specific types.

    `Constant'
          Removes the prefix specified for constant and number names
          and turns off the check for these names.

    `Exception'
          Removes the prefix specified for exception names and turns
          off the check for exception names.

    `Enum'
          Removes the prefix specified for enumeration literal names and
          turns off the check for them.

    `Exclusive'
          Turns of the check that only names of specific kinds of
          entities have prefixes specified for these kinds.

If more than one parameter is used, parameters must be separated by
commas.

   If more than one option is specified for the gnatcheck invocation, a
new option overrides the previous one(s).

   The `+RIdentifier_Prefixes' option (with no parameter) enables checks
for all the name prefixes specified by previous options used for this
rule. If no prefix is specified, the rule is not enabled.

   The `-RIdentifier_Prefixes' option (with no parameter) disables all
the checks but keeps all the prefixes specified by previous options
used for this rule.

   There is no default prefix setting for this rule. All checks for
name prefixes are case-sensitive

   If any error is detected in a rule parameter, that parameter is
ignored.  In such a case the options that are set for the rule are not
specified.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>controlled_type_declarations</key>
    <name>controlled types</name>
    <description>      Flag all declarations of controlled types. A declaration of a private
type is flagged if its full declaration declares a controlled type. A
declaration of a derived type is flagged if its ancestor type is
controlled. Subtype declarations are not checked. A declaration of a
type that itself is not a descendant of a type declared in
`Ada.Finalization' but has a controlled component is not checked.

   This rule has no parameters.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>blocks</key>
    <name>block statements</name>
    <description>      Flag each block statement.

   This rule has no parameters.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>exit_statements_with_no_loop_name</key>
    <name>exit statements with no loop name</name>
    <description>      Flag each `exit' statement that does not specify the name of the loop
being exited.

   The rule has no parameters.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>forbidden_attributes</key>
    <name>detect specified attributes (use ',' as separator)</name>
    <description>      Flag each use of the specified attributes. The attributes to be
detected are named in the rule's parameters.

   This rule has the following parameters:

   * For the `+R' option

    _Attribute_Designator_
          Adds the specified attribute to the set of attributes to be
          detected and sets the detection checks for all the specified
          attributes ON.  If _Attribute_Designator_ does not denote any
          attribute defined in the Ada standard or in *note
          Implementation Defined Attributes: (gnat_rm)Implementation
          Defined Attributes, it is treated as the name of unknown
          attribute.

    `GNAT'
          All the GNAT-specific attributes are detected; this sets the
          detection checks for all the specified attributes ON.

    `ALL'
          All attributes are detected; this sets the rule ON.

   * For the `-R' option
    _Attribute_Designator_
          Removes the specified attribute from the set of attributes to
          be detected without affecting detection checks for other
          attributes. If _Attribute_Designator_ does not correspond to
          any attribute defined in the Ada standard or in *note
          Implementation Defined Attributes: (gnat_rm)Implementation
          Defined Attributes, this option is treated as turning OFF
          detection of all unknown attributes.

    GNAT
          Turn OFF detection of all GNAT-specific attributes

    ALL
          Clear the list of the attributes to be detected and turn the
          rule OFF.

Parameters are not case sensitive. If _Attribute_Designator_ does not
have the syntax of an Ada identifier and therefore can not be
considered as a (part of an) attribute designator, a diagnostic message
is generated and the corresponding parameter is ignored. (If an
attribute allows a static expression to be a part of the attribute
designator, this expression is ignored by this rule.)

   When more than one parameter is given in the same rule option, the
parameters must be separated by commas.

   If more than one option for this rule is specified for the gnatcheck
call, a new option overrides the previous one(s).

   The `+R' option with no parameters turns the rule ON, with the set of
attributes to be detected defined by the previous rule options.  (By
default this set is empty, so if the only option specified for the rule
is `+RForbidden_Attributes' (with no parameter), then the rule is
enabled, but it does not detect anything).  The `-R' option with no
parameter turns the rule OFF, but it does not affect the set of
attributes to be detected.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>unconditional_exits</key>
    <name>Exit statement with no condition</name>
    <description>      Flag unconditional `exit' statements.

   This rule has no parameters.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>identifier_suffixes:renaming_suffix</key>
    <name>suffix for package renaming names (empty string disables check)</name>
    <description>      Flag the declaration of each identifier that does not have a suffix
corresponding to the kind of entity being declared.  The following
declarations are checked:

   * type declarations

   * subtype declarations

   * constant declarations (but not number declarations)

   * package renaming declarations (but not generic package renaming
     declarations)

This rule may have parameters. When used without parameters, the rule
enforces the following checks:

   * type-defining names end with `_T', unless the type is an access
     type, in which case the suffix must be `_A'

   * constant names end with `_C'

   * names defining package renamings end with `_R'

Defining identifiers from incomplete type declarations are never
flagged.

   For a private type declaration (including private extensions), the
defining identifier from the private type declaration is checked
against the type suffix (even if the corresponding full declaration is
an access type declaration), and the defining identifier from the
corresponding full type declaration is not checked.

For a deferred constant, the defining name in the corresponding full
constant declaration is not checked.

   Defining names of formal types are not checked.

   The rule may have the following parameters:

   * For the `+R' option: unless the parameter is `Default', then only
     the explicitly specified suffix is checked, and no defaults are
     used.
    `Default'
          Sets the default listed above for all the names to be checked.

    `Type_Suffix=_string_'
          Specifies the suffix for a type name.

    `Access_Suffix=_string_'
          Specifies the suffix for an access type name. If this
          parameter is set, it overrides for access types the suffix
          set by the `Type_Suffix' parameter.  For access types,
          _string_ may have the following format: _suffix1(suffix2)_.
          That means that an access type name should have the _suffix1_
          suffix except for the case when the designated type is also
          an access type, in this case the type name should have the
          _suffix1 &amp; suffix2_ suffix.

    `Class_Access_Suffix=_string_'
          Specifies the suffix for the name of an access type that
          points to some class-wide type.  If this parameter is set, it
          overrides for such access types the suffix set by the
          `Type_Suffix' or `Access_Suffix' parameter.

    `Class_Subtype_Suffix=_string_'
          Specifies the suffix for the name of a subtype that denotes a
          class-wide type.

    `Constant_Suffix=_string_'
          Specifies the suffix for a constant name.

    `Renaming_Suffix=_string_'
          Specifies the suffix for a package renaming name.

   * For the `-R' option:
    `All_Suffixes'
          Remove all the suffixes specified for the identifier suffix
          checks, whether by default or as specified by other rule
          parameters. All the checks for this rule are disabled as a
          result.

    `Type_Suffix'
          Removes the suffix specified for types. This disables checks
          for types but does not disable any other checks for this rule
          (including the check for access type names if `Access_Suffix'
          is set).

    `Access_Suffix'
          Removes the suffix specified for access types.  This disables
          checks for access type names but does not disable any other
          checks for this rule.  If `Type_Suffix' is set, access type
          names are checked as ordinary type names.

    `Class_Access_Suffix'
          Removes the suffix specified for access types pointing to
          class-wide type. This disables specific checks for names of
          access types pointing to class-wide types but does not
          disable any other checks for this rule.  If `Type_Suffix' is
          set, access type names are checked as ordinary type names. If
          `Access_Suffix' is set, these access types are checked as any
          other access type name.

    `Class_Subtype_Suffix=_string_'
          Removes the suffix specified for subtype names.  This
          disables checks for subtype names but does not disable any
          other checks for this rule.

    `Constant_Suffix'
          Removes the suffix specified for constants. This disables
          checks for constant names but does not disable any other
          checks for this rule.

    `Renaming_Suffix'
          Removes the suffix specified for package renamings. This
          disables checks for package renamings but does not disable
          any other checks for this rule.

If more than one parameter is used, parameters must be separated by
commas.

   If more than one  option is specified for the `gnatcheck' invocation,
a new option overrides the previous one(s).

   The `+RIdentifier_Suffixes' option (with no parameter) enables
checks for all the name suffixes specified by previous options used for
this rule.

   The `-RIdentifier_Suffixes' option (with no parameter) disables all
the checks but keeps all the suffixes specified by previous options
used for this rule.

   The _string_ value must be a valid suffix for an Ada identifier
(after trimming all the leading and trailing space characters, if any).
Parameters are not case sensitive, except the _string_ part.

   If any error is detected in a rule parameter, the parameter is
ignored.  In such a case the options that are set for the rule are not
specified.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>too_many_parents</key>
    <name>type/object has too many parents</name>
    <description>      Flag any tagged type declaration, interface type declaration, single
task declaration or single protected declaration that has more than `N'
parents, where `N' is a parameter of the rule.  A parent here is either
a (sub)type denoted by the subtype mark from the
parent_subtype_indication (in case of a derived type declaration), or
any of the progenitors from the interface list (if any).

   This rule has the following (mandatory) parameters for the `+R'
option:

_N_
     Positive integer specifying the maximal allowed number of
     parents/progenitors.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>name_clashes</key>
    <name>restrictions on name space (specify dictionary of forbidden names)</name>
    <description>      Check that certain names are not used as defining identifiers. The
names that should not be used as identifiers must be listed in a
dictionary file that is a rule parameter. A defining identifier is
flagged if it is included in a dictionary file specified as a rule
parameter, the check is not case-sensitive.  More then one dictionary
file can be specified as the rule parameter, in this case the rule
checks defining identifiers against the union of all the identifiers
from all the dictionary files provided as the rule parameters.

   This rule has the following (mandatory) parameters for the `+R'
option:

__dictionary_file__
     The name of a dictionary file.

   This rule is enabled by default, but without setting any
corresponding dictionary file(s); thus the default effect is to do no
checks.

   A dictionary file is a plain text file. The maximum line length for
this file is 1024 characters.  If the line is longer than this limit,
extra characters are ignored.

   Each line can be either an empty line, a comment line, or a line
containing a list of identifiers separated by space or HT characters.
A comment is an Ada-style comment (from `--' to end-of-line).
Identifiers must follow the Ada syntax for identifiers.  A line
containing one or more identifiers may end with a comment.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>identifier_casing:constant</key>
    <name>constant name casing</name>
    <description>      Flag each defining identifier that does not have a casing corresponding
to the kind of entity being declared. All defining names are checked.
For the defining names from the following kinds of declarations a
special casing scheme can be defined:

   * type and subtype declarations;

   * enumeration literal specifications (not including character
     literals) and function renaming declarations if the renaming
     entity is an enumeration literal;

   * constant and number declarations (including object renaming
     declarations if the renamed object is a constant);

   * exception declarations and exception renaming declarations.

   The rule may have the following parameters for `+R':

`Type=_casing_scheme_'
     Specifies casing for names from type and subtype declarations.

`Enum=_casing_scheme_'
     Specifies the casing of defining enumeration literals and for the
     defining names in a function renaming declarations if the renamed
     entity is an enumeration literal.

`Constant=_casing_scheme_'
     Specifies the casing for defining names from constants and named
     number declarations, including the object renaming declaration if
     the renamed object is a constant

`Exception=_casing_scheme_'
     Specifies the casing for names from exception declarations and
     exception renaming declarations.

`Others=_casing_scheme_'
     Specifies the casing for all defining names for which no special
     casing scheme is specified. If this parameter is not set, the
     casing for the entities that do not correspond to the specified
     parameters is not checked.

`Exclude=_dictionary_file_'
     Specifies casing exceptions.

Where:

        casing_scheme ::= upper|lower|mixed

_upper_ means that the defining identifier should be upper-case.
_lower_ means that the defining identifier should be lower-case _mixed_
means that the first defining identifier letter and the first letter
after each underscore should be upper-case, and all the other letters
should be lower-case

   If a defining identifier is from a declaration for which a specific
casing scheme can be set, but the corresponding parameter is not
specified for the rule, then the casing scheme defined by `Others'
parameter is used to check this identifier. If `Others' parameter also
is not set, the identifier is not checked.

   _dictionary_file_ is the name of the text file that contains casing
exceptions. The way how this rule is using the casing exception
dictionary file is consistent with using the casing exception
dictionary in the GNAT pretty-printer `gnatpp', see `GNAT Pro User's
Guide'.

   There are two kinds of exceptions:

_identifier_
     If a dictionary file contains an identifier, then each occurrence
     of that (defining) identifier in the checked source should use the
     casing specified included in _dictionary_file_

_wildcard_
     A wildcard has the following syntax

            WILDCARD ::= *SIMPLE_IDENTIFIER* |
                               *SIMPLE_IDENTIFIER |
                               SIMPLE_IDENTIFIER*
            SIMPLE_IDENTIFIER ::= LETTER{LETTER_OR_DIGIT}

     `simple_identifier' specifies the casing of subwords (the term
     "subword" is used below to denote the part of a name which is
     delimited by "_" or by the beginning or end of the word and which
     does not contain any "_" inside).  A wildcard of the form
     `simple_identifier*' defines the casing of the first subword of a
     defining name to check, the wildcard of the form
     `*simple_identifier' specifies the casing of the last subword, and
     the wildcard of the form `*simple_identifier*' specifies the
     casing of any subword.

     If for a defining identifier some of its subwords can be mapped
     onto wildcards, but some other cannot, the casing of the
     identifier subwords that are not mapped onto wildcards from casing
     exception dictionary is checked against the casing scheme defined
     for the corresponding entity.

   If some identifier is included in the exception dictionary both as a
whole identifier and can be mapped onto some wildcard from the
dictionary, then it is the identifier and not the wildcard that is used
to check the identifier casing.

   If more than one dictionary file is specified, or a dictionary file
contains more than one exception variant for the same identifier, the
new casing exception overrides the previous one.

   Casing check against dictionary file(s) has a higher priority than
checks against the casing scheme specified for a given
entity/declaration kind.

   `+R' option should contain at least one parameter.

   There is no parameter for `-R' option, it just turns the rule off.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>default_parameters</key>
    <name>declarations of default subprogram parameters</name>
    <description>      Flag all default expressions in parameters specifications. All parameter
specifications are checked: in subprograms (including formal, generic
and protected subprograms) and in task and protected entries (including
accept statements and entry bodies).

   This rule has no parameters.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>numeric_literals:statements_only</key>
    <name>check numeric literals on statements only</name>
    <description>      Flag each use of a numeric literal in an index expression, and in any
circumstance except for the following:

   * a literal occurring in the initialization expression for a constant
     declaration or a named number declaration, or

   * an integer literal that is less than or equal to a value specified
     by the `N' rule parameter.

   * a literal occurring in a declaration in case the `Statements_Only'
     rule parameter is given

This rule may have the following parameters for the `+R' option:

_N_
     _N_ is an integer literal used as the maximal value that is not
     flagged (i.e., integer literals not exceeding this value are
     allowed)

`ALL'
     All integer literals are flagged

`Statements_Only'
     Numeric literals are flagged only when used in statements

If no parameters are set, the maximum unflagged value is 1, and the
check for literals is not limited by statements only.

   The last specified check limit (or the fact that there is no limit at
all) is used when multiple `+R' options appear.

   The `-R' option for this rule has no parameters.  It disables the
rule and restores its default operation mode.  If the `+R' option
subsequently appears, will be 1, and the check will not be limited by
statements only.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>others_in_exception_handlers</key>
    <name>OTHERS choices in exception handlers</name>
    <description>      Flag any use of an `others' choice in an exception handler.

   This rule has no parameters.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>exceptions_as_control_flow</key>
    <name>exceptions for control flow</name>
    <description>      Flag each place where an exception is explicitly raised and handled in
the same subprogram body. A `raise' statement in an exception handler,
package body, task body or entry body is not flagged.

   The rule has no parameters.</description>
    <tag>gnatcheck</tag>
  </rule>
  <rule>
    <key>improperly_located_instantiations</key>
    <name>instantiations that can cause problems</name>
    <description>      Flag all generic instantiations in library-level package specs
(including library generic packages) and in all subprogram bodies.

   Instantiations in task and entry bodies are not flagged.
Instantiations in the bodies of protected subprograms are flagged.

   This rule has no parameters.</description>
    <tag>gnatcheck</tag>
  </rule>
</rules>
